<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>모션 플래닝</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <script src="../../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="모션 계획 기능 및 변수에 대한 참조 섹션" />
  <meta name="rh-index-keywords" content="" />
  <meta name="search-keywords" content="모션 플래닝,MP,MP 함수" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> 모션 플래닝</h1><p> 많은 게임에서 상대방, NPC, 적 등이 플레이어와 상호 작용하고 이동할 때 특정 지능을 보여주기를 원합니다. 이 <span data-keyref="GameMaker Name">GameMaker</span> 를 돕기 위해 모션 계획을 다루는 일련의 기능이 있습니다. 이것들은 게임 적과 같은 것을 위해 설계되었지만 텍스트를 도입하는 부드러운 방법을 만들거나 전환을 만드는 것과 같은 모든 종류의 일에 사용될 수 있습니다. 그러나 아래 목록에서 사용하기로 선택한 것은 무엇이든 게임의 경우 많은 상황에서 단일 기능 세트가 완벽한 솔루션을 제공하지 않으며 게임 내 상황에 따라 하나 또는 다른 기능을 사용하여 기능을 &quot;믹스 앤 매치&quot;해야 한다는 점에 유의해야 합니다.</p><p> GameMaker의 모션 계획은 <span data-keyref="GameMaker Name">mp_</span> 함수에 의해 처리되며 <b>자체적</b> 으로 다음 세 그룹으로 나뉩니다.</p><h2> <label for="one">선형 함수</label></h2><p> 이러한 종류의 함수는 인스턴스에 대한 충돌 없는 경로를 계산하려고 합니다. 이 경로가 계산되면 인스턴스에 할당하여 목표를 향해 이동할 수 있습니다. 경로 계산에는 시간이 걸리지만 그 후에는 경로 실행이 빠릅니다. 물론 이것은 그 동안 상황이 변경되지 않은 경우에만 유효합니다. 예를 들어 장애물이 바뀌면 경로를 다시 계산해야 할 수도 있습니다. 이러한 기능이 실패할 수 있고 인스턴스에 대한 경로를 찾을 수 없다는 점에 다시 주의하십시오.</p><ul class="colour"><li> <a href="mp_linear_step.htm"><span class="notranslate">mp_linear_step</span></a></li><li> <a href="mp_linear_step_object.htm"><span class="notranslate">mp_linear_step_object</span></a></li><li> <a href="mp_linear_path.htm"><span class="notranslate">mp_linear_path</span></a></li><li> <a href="mp_linear_path_object.htm"><span class="notranslate">mp_linear_path_object</span></a></li></ul><p></p><h2> <label for="three">잠재적 기능</label></h2><p> 기본적인 회피 기능들이며 간단한 AI에 좋습니다. 그들은 인스턴스가 특정 목표 위치를 향해 한 발짝 내딛게 하는 동시에 가능하면 직진하려고 하지만 필요한 경우 다른 방향을 취하게 하여 작동합니다. 이러한 기능은 인스턴스의 <b>단계 이벤트</b> 에서 사용해야 합니다.</p><ul class="colour"><li> <a href="mp_potential_settings.htm"><span class="notranslate">mp_potential_settings</span></a></li><li> <a href="mp_potential_step.htm"><span class="notranslate">mp_potential_step</span></a></li><li> <a href="mp_potential_step_object.htm"><span class="notranslate">mp_potential_step_object</span></a></li><li> <a href="mp_potential_path.htm"><span class="notranslate">mp_potential_path</span></a></li><li> <a href="mp_potential_path_object.htm"><span class="notranslate">mp_potential_path_object</span></a></li></ul><p></p><h2> <label for="two">그리드 함수</label></h2><p> 마지막 유형의 함수는 그리드 기반 접근 방식(A* 알고리즘이라고도 함)을 기반으로 하는 훨씬 더 복잡한 메커니즘을 사용합니다. 경로를 찾는 데 훨씬 더 성공적이며(여전히 실패할 수 있음) 가능한 가장 짧은 경로를 찾을 수 있지만 설정하려면 더 많은 작업이 필요합니다.</p><p> 전체적인 아이디어는 다음과 같습니다. - 먼저 방(또는 방의 관련 부분)을 덮는 그리드를 만듭니다. 더 느린 미세 격자 또는 거친 격자를 사용할 수 있지만 둘 다 공간의 해상도를 기반으로 하여 경로 찾기가 가능한 한 정확해야 합니다. 예를 들어 공간이 400x200픽셀인 경우 격자 해상도를 40, 20 또는 10으로 설정할 수 있습니다. 모든 것은 경로가 얼마나 정확해야 하고 GameMaker가 처리하기를 원하는 정도에 따라 다릅니다. 생성하도록 합니다.</p><p> 다음으로, 피하고 싶은 모든 관련 객체에 대해 겹치는 그리드 셀을 결정하고(바운딩 상자 또는 정확한 스프라이트를 기반으로) 이러한 셀을 금지된 것으로 표시해야 합니다. 따라서 장애물이 부분적으로만 겹치더라도 셀은 완전히 금지된 것으로 표시됩니다.</p><p> 마지막으로 시작 위치와 목표 위치를 지정합니다. 둘 다 자유 셀에 <i>있어야</i> 하며, 함수는 이 두 위치 사이에서 가능한 최단 경로를 계산합니다. 경로는 모든 자유 셀의 중심 사이에서 실행되므로 중심에 배치된 인스턴스가 완전히 내부에 놓일 만큼 셀이 충분히 크면 성공할 것입니다. 이 경로는 다음을 사용하여 따를 인스턴스에 할당됩니다.<a href="../../Asset_Management/Paths/Paths.htm"><span class="inline">path_*</span></a> 기능. 셀의 중심을 원점으로 하여 배치된 움직이는 물체가 <i>완전히</i> 셀 내부에 놓일 수 있을 만큼 셀이 충분히 커야 하기 때문에 셀 크기가 얼마나 중요한지 깨달아야 합니다. (객체의 원점 위치에주의하십시오. 또한 객체의 원점이 중앙에 있지 않으면 경로를 이동할 수 있음을 명심하십시오!) 반면에 셀이 작을수록 가능한 경로가 더 많이 있습니다. 셀을 너무 크게 만들면 모든 셀이 장애물과 교차하기 때문에 장애물 사이의 구멍이 닫힐 수 있습니다.</p><ul class="colour"><li> <a href="mp_grid_create.htm"><span class="notranslate">mp_grid_create</span></a></li><li> <a href="mp_grid_destroy.htm"><span class="notranslate">mp_grid_destroy</span></a></li><li> <a href="mp_grid_path.htm"><span class="notranslate">mp_grid_path</span></a></li><li> <a href="mp_grid_add_cell.htm"><span class="notranslate">mp_grid_add_cell</span></a></li><li> <a href="mp_grid_add_instances.htm"><span class="notranslate">mp_grid_add_instances</span></a></li><li> <a href="mp_grid_add_rectangle.htm"><span class="notranslate">mp_grid_add_rectangle</span></a></li><li> <a href="mp_grid_get_cell.htm"><span class="notranslate">mp_grid_get_cell</span></a></li><li> <a href="mp_grid_clear_all.htm"><span class="notranslate">mp_grid_clear_all</span></a></li><li> <a href="mp_grid_clear_cell.htm"><span class="notranslate">mp_grid_clear_cell</span></a></li><li> <a href="mp_grid_clear_rectangle.htm"><span class="notranslate">mp_grid_clear_rectangle</span></a></li><li> <a href="mp_grid_to_ds_grid.htm"><span class="notranslate">mp_grid_to_ds_grid</span></a></li><li> <a href="mp_grid_draw.htm"><span class="notranslate">mp_grid_draw</span></a></li></ul><p></p><p> 그리드 기반 접근 방식은 매우 강력하지만(많은 프로 게임에서 사용됨) 게임을 해결하기에 충분한 영역과 셀 크기를 결정해야 하므로 신중하게 생각해야 합니다. 또한 피해야 할 물건과 정확한 확인이 중요한지 여부를 결정해야 합니다. 이러한 모든 매개변수는 접근 방식의 효율성에 큰 영향을 미칩니다. 또한 비용이 적게 드는 것 중 하나로 실제로 필요한지 여부도 결정해야 합니다. <span class="inline">mp_*</span> 함수도 작업을 수행할 수 있습니다. </p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> 등: <a href="../Movement_And_Collisions.htm">움직임과 충돌</a></div><div style="float:right"> 다음: <a href="../Collisions/Collisions.htm">충돌</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2021 판권 소유</span></h5>
  </div>
  <!-- KEYWORDS
Motion Planning
MP Functions
Motion Planning Functions
-->
  <!-- TAGS
mp_functions
-->
</body>
</html>