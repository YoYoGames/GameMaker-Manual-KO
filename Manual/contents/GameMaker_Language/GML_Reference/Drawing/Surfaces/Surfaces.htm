<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>표면</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <script src="../../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Surface 함수 및 변수에 대한 참조 섹션" />
  <meta name="rh-index-keywords" content="" />
  <meta name="search-keywords" content="표면,application_surface,적용면,앱 표면" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> 표면</h1><p> 일반 그리기 이벤트에서 <span data-keyref="GameMaker Name">GameMaker</span> 는 실제로 화면에 직접 그리는 것이 아니라 <i>응용 프로그램 표면</i> <b>이라는 표면</b> 에 그립니다. 이 표면은 기본적으로 나중에 필요할 때 화면에 그리기 전에 조작할 수 있는 빈 &quot;캔버스&quot;이며, 대부분의 경우 <span data-keyref="GameMaker Name">GameMaker</span> 가 이를 대신 처리합니다(단, 셰이더, 크기 조정 및 기타 여러 코드에서 직접 조작할 수도 있습니다. 사물 - 자세한 내용은 아래에 나와 있습니다).</p><p> 그러나 이 응용 프로그램 표면 외에도 고유한 표면을 만들고 이를 사용하여 게임에서 놀랍거나 미묘한 특수 효과를 만들 수도 있습니다. 예를 들어, 표면을 사용하여 인스턴스를 &quot;잡아&quot; 파괴할 수 있으며, 이러한 방식으로 인스턴스의 스프라이트가 표면에 여전히 존재하는 것처럼 표시되는 데칼 효과를 생성하여 다음과 같은 그래픽 효과를 허용할 수 있습니다. 실제 처리 오버헤드 없이 파편, 혈액 등. 표면으로 할 수 있는 또 다른 작업은 표면을 조작할 텍스처로 사용하거나 &quot;즉석에서&quot; 스프라이트를 만들거나 복잡한 오버레이를 만드는 것입니다. 사실, 표면의 용도는 끝이 없습니다!</p><p> 일반 표면은 사용하기가 매우 쉽지만 사용할 때 따라야 할 몇 가지 기본 규칙이 있습니다.</p><ul class="colour"><li> 먼저 표면(애플리케이션 표면 <i>제외</i> )이 &quot;휘발성&quot;이라는 것을 알아야 합니다. 즉, 장치 또는 창이 포커스를 잃거나 최소화된 경우(좋은 예는 다른 창으로 ALT +Tab을 눌렀다가 다시 Windows로 돌아오는 경우 또는 Android 장치에서 앱이 호출로 인해 포커스를 잃을 때) 표면 <strong>이 파괴되다</strong>. 이는 텍스처 메모리( <a class="glossterm" data-glossterm="VRAM" href="#">VRAM</a> ) <em>에만</em> 저장되고 대상 플랫폼이 다른 용도로 해당 메모리를 필요로 할 때 덮어쓸 수 <i><b>있기</b></i> 때문입니다.<a href="surface_exists.htm"><span class="inline">surface_exists()</span></a> 기능. </li></ul><p class="note" style="padding-top: 0.5em;padding-right: 1em;padding-bottom: 0.5em;padding-left: 4em"> <span class="note">노트</span><strong> </strong>이것은 스프라이트나 다른 시각적 자산에서는 발생하지 않는 것 같지만(실제로는 발생합니다!) 일반 메모리(RAM)에도 저장되고 텍스처 메모리(VRAM)에서 제거될 때 일반 메모리에서 즉시 복원됩니다. 게임이 초점을 되찾습니다.</p><ul class="colour"><li> 둘째, 표면을 사용하려면 많은 양의 VRAM이 필요할 수 있으므로 가능한 한 작게 유지해야 합니다. 일반적으로 보기 또는 표시 창의 크기보다 크지 않게 유지하려고 합니다.</li><li> 셋째, <b>그리기 이벤트에서 표면만 생성</b> 해야 합니다. 인스턴스의 이벤트 생성에서 표면을 생성하면 잠재적으로 <i>동일한</i> 인덱스를 얻을 수 있습니다. <span class="inline">application_surface</span>. 그러면 자신의 표면을 사용하고 있다고 생각하지만 실제로는 현재 렌더 대상을 사용하고 있기 때문에 많은 문제와 혼란을 일으킬 수 있습니다. <span data-keyref="GameMaker Name">GameMaker</span> 가 화면에 <i>그리는</i> 최적화된 방식으로 인해 <i>그리기 이벤트 내에서</i> 모든 그리기 기능을 유지하는 것이 좋습니다. 여기에는 표면 지우기가 포함됩니다. 처음 생성될 때 등... 그리기 이벤트 외부의 표면에 그리기가 가능하고 일부 효과에 필요할 수도 있지만 어떻게 <em>해야</em> 하는 것은 아닙니다.</li><li> 넷째, 표면에 수동으로 그릴 때 표면은 <i>항상</i> (0,0)의 위치에 있습니다. 즉, <em>절대</em> 좌표를 표면의 <em>상대</em> 좌표로 변환해야 할 수도 있습니다. 예를 들어, 카메라 크기의 표면이 있고 현재 카메라에서 볼 수 있는 것을 해당 표면에 그리려면 실제 x 및 y 좌표에서 카메라 보기 x 및 y 좌표를 빼서 에 대한 상대 위치를 얻어야 합니다. 표면(0,0) 위치. 따라서 코드는 다음과 같이 보일 것입니다.</li></ul><p class="code">if view_current = 0<br />
    {<br />
        surface_set_target(surf);<br />
        with (obj_effect)<br />
        {<br />
            var _vx = camera_get_view_x(view_camera[1]);<br />
            var _vy = camera_get_view_y(view_camera[1]);<br />
            draw_sprite(sprite_index, image_index, x - _vx, y - _vy);<br />
        }<br />
        surface_reset_target();<br />
    }<br />
    else<br />
    {<br />
        draw_surface(surf, 0, 0);<br />
    }</p><ul class="colour"><li> 마지막으로, 표면에 그릴 때 표면 자체와 표면에 그려지는 것 모두에서 각 픽셀의 색상 <em>과</em> 알파 구성 요소를 고려한다는 점에 주목할 가치가 있습니다. 이것은 다소 직관적이지 않은 결과로 이어질 수 있습니다(예를 들어, 0.5 알파가 있는 스프라이트를 0 알파가 있는 표면에 그리면 최종 알파가 0.25가 됩니다). 그 이유는 다음 페이지에 설명되어 있으며 표면으로 작업하기 전에 읽을 것을 권장합니다. <a href="../../../../Additional_Information/Guide_To_Using_Blendmodes.htm">블렌드 모드 사용 가이드</a></li></ul><p class="note"> <span class="note">참고</span> 이것은 <a href="application_surface.htm">응용 프로그램 표면</a> 에는 해당되지 않고 사용자가 만든 표면에만 해당됩니다.</p><p> 표면의 기본 용도는 다음과 같습니다.</p><ul class="colour"><li> 먼저 표면을 만들고 해당 인덱스를 변수에 할당합니다.</li><li> 그런 다음 드로잉 대상을 디스플레이가 아닌 표면으로 설정합니다.</li><li> 다음으로 원하는 것을 그리고 다른 조작을 수행합니다.</li><li> 완료되면 모든 추가 드로잉이 화면에서 다시 발생하도록 드로잉 대상을 재설정합니다.</li><li> 마지막으로 표면을 그립니다(또는 셰이더에서 사용하거나 필요한 모든 것).</li></ul><p> 한 가지 주의할 점은 전체 디스플레이를 표면(타일, 배경 등... 포함)에 그려야 하는 경우 애플리케이션 표면 자체에 간단히 액세스하거나(자세한 내용은 아래 참조) 보기에 표면을 할당할 수 있다는 것입니다. 변수를 사용하는 포트 <a href="../../Cameras_And_Display/Cameras_And_Viewports/view_surface_id.htm"><span class="inline">view_surface_id[0..7]</span></a> 이것과 마찬가지로 해당 뷰 포트에서 볼 수 있는 모든 것이 해당 표면으로 그려집니다.</p><p> 다음 함수는 표면을 처리하기 위해 존재합니다(이 함수는 표면을 만들고 조작하는 데만 사용되지만 실제로 화면에 그리기 위해서는 아래에서 찾을 수 있는 특정 그리기 기능을 사용해야 합니다).</p><ul class="colour"><li> <a href="surface_exists.htm"><span class="notranslate">surface_exists</span></a></li><li> <a href="surface_create.htm"><span class="notranslate">surface_create</span></a></li><li> <a href="surface_create_ext.htm"><span class="notranslate">surface_create_ext</span></a></li><li> <a href="surface_resize.htm"><span class="notranslate">surface_resize</span></a></li><li> <a href="surface_set_target.htm"><span class="notranslate">surface_set_target</span></a></li><li> <a href="surface_set_target_ext.htm"><span class="notranslate">surface_set_target_ext</span></a></li><li> <a href="surface_get_target.htm"><span class="notranslate">surface_get_target</span></a></li><li> <a href="surface_get_target_ext.htm"><span class="notranslate">surface_get_target_ext</span></a></li><li> <a href="surface_reset_target.htm"><span class="notranslate">surface_reset_target</span></a></li><li> <a href="surface_copy.htm"><span class="notranslate">surface_copy</span></a></li><li> <a href="surface_copy_part.htm"><span class="notranslate">surface_copy_part</span></a></li><li> <a href="surface_depth_disable.htm"><span class="notranslate">surface_depth_disable</span></a></li><li> <a href="surface_get_height.htm"><span class="notranslate">surface_get_height</span></a></li><li> <a href="surface_get_width.htm"><span class="notranslate">surface_get_width</span></a></li><li> <a href="surface_get_texture.htm"><span class="notranslate">surface_get_texture</span></a></li><li> <a href="surface_get_depth_disable.htm"><span class="notranslate">surface_get_depth_disable</span></a></li><li> <a href="surface_getpixel.htm"><span class="notranslate">surface_getpixel</span></a></li><li> <a href="surface_getpixel_ext.htm"><span class="notranslate">surface_getpixel_ext</span></a></li><li> <a href="surface_free.htm"><span class="notranslate">surface_free</span></a></li><li> <a href="surface_save.htm"><span class="notranslate">surface_save</span></a></li><li> <a href="surface_save_part.htm"><span class="notranslate">surface_save_part</span></a></li></ul><p></p><p> 표면 그리기에는 다음과 같은 기능이 있습니다.</p><p class="note"> <b><span class="note">주</span></b> 표면으로 작업할 때 표면이 텍스처 메모리에 저장되어 있기 때문에 언제든지 존재하지 않을 가능성이 있습니다. 다음을 사용하여 표면이 존재하는지 <b>항상</b> 확인해야 합니다.<span style="font-size:1px;"><a href="surface_exists.htm"><span class="inline">surface_exists()</span></a></span> 직접 참조하기 전에.</p><ul class="colour"><li> <a href="draw_surface.htm"><span class="notranslate">draw_surface</span></a></li><li> <a href="draw_surface_ext.htm"><span class="notranslate">draw_surface_ext</span></a></li><li> <a href="draw_surface_part.htm"><span class="notranslate">draw_surface_part</span></a></li><li> <a href="draw_surface_part_ext.htm"><span class="notranslate">draw_surface_part_ext</span></a></li><li> <a href="draw_surface_stretched.htm"><span class="notranslate">draw_surface_stretched</span></a></li><li> <a href="draw_surface_stretched_ext.htm"><span class="notranslate">draw_surface_stretched_ext</span></a></li><li> <a href="draw_surface_tiled.htm"><span class="notranslate">draw_surface_tiled</span></a></li><li> <a href="draw_surface_tiled_ext.htm"><span class="notranslate">draw_surface_tiled_ext</span></a></li><li> <a href="draw_surface_general.htm"><span class="notranslate">draw_surface_general</span></a></li></ul><p></p><p> 마지막으로 <a href="../../Buffers/Buffers.htm">버퍼</a> 에 표면을 저장하고 검색하는 두 가지 기능이 있습니다.</p><ul class="colour"><li> <a href="../../Buffers/buffer_get_surface.htm"><span class="notranslate">buffer_get_surface</span></a></li><li> <a href="../../Buffers/buffer_set_surface.htm"><span class="notranslate">buffer_set_surface</span></a></li></ul><p></p><p> 위에서 언급했듯이 <span data-keyref="GameMaker Name">GameMaker</span> 는 실제로 대부분의 것을 화면에 직접 렌더링하지 않고 대신 <b>응용 프로그램 표면</b> 에 렌더링합니다. 이것은 본질적으로 표면입니다. 표면 기능을 사용하여 직접 만들 수 있는 것과 마찬가지로, 조작하고, 그리거나, 셰이더로 보낼 수 있습니다. 기본적으로 표면으로 일반적으로 수행하는 모든 작업 생성된 항목은 응용 프로그램 표면에도 적용할 수 있습니다.</p><p class="note"> <b>참고</b>: 응용 프로그램 표면으로 할 <b>수 없는</b> 유일한 것은 그것을 해제하는 것입니다. 액세스할 인덱스 값이 변경될 수 있지만 항상 존재합니다.</p><p> 게임을 실행할 때 이 표면은 새로 들어오는 각 방에서 <a href="../../../../The_Asset_Editors/Object_Properties/Draw_Events.htm">그리기 이벤트</a> 가 처음 호출될 때 만들어집니다. 즉, 그 지점까지 아무것도 그려지지 않습니다. 그러나 오류 없이 응용 프로그램 표면 위치를 가져오고 이벤트 <b>만들기</b> 또는 다른 이벤트에서 크기를 조정할 수 있으며 사용된 값은 표면이 생성될 때 표면과 관련됩니다. 애플리케이션 표면의 생성 및 그리기에 대한 실제 이벤트 순서는 다음과 같습니다.</p><ul class="colour"><li> 사전 추첨 이벤트<br /> --- &gt; <b>애플리케이션 표면이 생성되고(존재하지 않는 경우) 렌더 대상이 설정됩니다.</b></li><li><b></b> 보이는 각 뷰 포트에 대해 또는 활성 뷰 포트가 없는 경우 한 번<ul class="colour"><li> 추첨 시작 이벤트</li><li> 추첨 이벤트</li><li> 추첨 종료 이벤트<br /> --- &gt; <b>응용 프로그램 표면 렌더 대상이 여기에서 재설정됩니다.</b></li></ul></li><li><b></b> 추첨 후 이벤트<br /> --- &gt; <b>애플리케이션 표면은 이제 기본적으로 <a class="glossterm" data-glossterm="디스플레이 버퍼" href="#">디스플레이 버퍼</a> 에 그려집니다.<br /></b> (비록 이것을 사용하여 끌 수 있지만<span class="inline"><a href="application_surface_draw_enable.htm">application_surface_draw_enable()</a></span> )</li><li><b></b> GUI 시작 이벤트 그리기</li><li> GUI 이벤트 그리기</li><li> GUI 종료 이벤트 그리기</li></ul><p> 이 표면을 사용하면 셰이더를 사용하여 놀라운 전환을 쉽게 만들거나 화면을 가져와서 3D 형태로 감싸거나 저해상도 게임을 모든 해상도 화면으로 간단히 확장할 수 있습니다... 가능성은 무한합니다!</p><p> 이 표면에 액세스하려면 내장 전역 변수를 사용해야 합니다. <span class="inline">application_surface</span> 다음 페이지에 설명되어 있습니다.</p><ul class="colour"><li> <a href="application_surface.htm"><span class="notranslate">application_surface</span></a></li></ul><p></p><p> 또한 애플리케이션 표면 <em>에서만</em> 사용하도록 설계된 몇 가지 전문 기능이 있습니다.</p><ul class="colour"><li> <a href="application_surface_enable.htm"><span class="notranslate">application_surface_enable</span></a></li><li> <a href="application_surface_is_enabled.htm"><span class="notranslate">application_surface_is_enabled</span></a></li><li> <a href="application_get_position.htm"><span class="notranslate">application_get_position</span></a></li><li> <a href="application_surface_draw_enable.htm"><span class="notranslate">application_surface_draw_enable</span></a></li> </ul><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> 뒤로: <a href="../Drawing.htm">그리기</a></div><div style="float:right"> 다음: <a href="../Lighting/Lighting.htm">조명</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Surfaces
app surface
application surface
-->
  <!-- TAGS
surfaces_functions
-->
</body>
</html>