<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>접근자</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="다양한 접근자를 설명하는 페이지" />
  <meta name="rh-index-keywords" content="접근자" />
  <meta name="search-keywords" content="접근자,@,[| ],[@ ],[# ],[? ],그리드 접근자,목록 접근자,지도 접근자,배열 접근자" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> 접근자</h1><p> GameMaker Language(GML)는 또한 접근자 라고 하는 논리 표현식을 사용하여 특정 <a href="../GML_Reference/Data_Structures/Data_Structures.htm">데이터 구조</a> 및 <a href="Arrays.htm">배열</a> 에 <b>접근</b> 할 수 있도록 합니다. 이것은 일반적으로 배열로 작업할 때와 유사한 방식으로 구성되어 있습니다. 첫 번째 인수 앞에 <em>식별자 기호</em> 만 사용하여 <span data-keyref="GameMaker Name">GameMaker</span> 에 (이전에 생성된) 데이터 구조 또는 배열 리터럴에서 작업 중임을 알립니다.</p><p></p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">DS 목록 [| ]</a></p><div class="droptext" data-targetname="drop-down10"><p class="dropspot"> <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">DS 목록</a> 의 구문은 다음과 같습니다.</p><p class="code">list_index[| index]</p><p class="dropspot"> 그래서 당신이 사용했을 때<span class="inline">ds_list_create()</span> 목록을 만들려면 목록 인덱스(변수에 저장한)를 사용하여 참조하고 &quot;색인&quot; 값은 설정하거나 추가할 목록의 위치입니다. 예를 들어 다음 코드는 목록을 만든 다음 10개의 항목을 추가하여 각 항목을 0에서 9 사이의 임의의 숫자로 설정합니다.</p><p class="code">ds = ds_list_create();<br />
      var index = 0;<br />
      repeat(10)<br />
      {<br />
          ds[| index++] = irandom(9);<br />
      }</p><p class="dropspot"> 표현식을 사용하여 이미 값이 있는 인덱스에 대한 참조를 추가하는 경우 목록에 추가 인덱스가 추가되지 않고 이전 값이 대체됩니다. 항목을 더 추가하려면 ds_list 크기를 알고 끝에 추가해야 합니다. 또한 참조되는 목록의 크기 <i>보다 큰</i> 목록 인덱스를 설정할 수 있으며, 이렇게 하면 해당 값이 설정되고 목록이 동시에 확장되고 목록의 모든 위치가 지정된 값까지 초기화됩니다. 인덱스를 0으로 합니다.</p><p class="dropspot"> 목록 구조를 만들고 데이터로 채우면 목록에서 값을 얻으려면 다음과 같이 됩니다.</p><p class="code">value = ds[| 5];</p><p class="dropspot"> 위는 위치 5(목록이 0에서 시작하기 때문에 여섯 번째 인덱스)에서 값을 가져와 변수에 저장합니다. 목록 크기를 벗어난 위치를 제공하면 값 <span class="inline">undefined</span> 함수 사용을 확인할 수 있는 반환됩니다.<a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">DS 맵 [? ]</a></p><div class="droptext" data-targetname="drop-down13"><p class="dropspot"> <a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS 맵</a> 의 구문은 다음과 같습니다.</p><p class="code">map_index[? key]</p><p class="dropspot"> 로 지도를 만든 후<span class="inline">ds_map_create()</span>, 변수에 저장한 맵 인덱스를 사용하여 참조하며 &quot;key&quot; 값은 설정하거나 가져올 맵 키입니다. 예를 들어 다음 코드는 맵을 만든 다음 이 구문을 사용하여 맵에 몇 가지 항목을 추가합니다.</p><p class="code">ds = ds_map_create();<br />
      ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br />
      ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br />
      ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p><p class="dropspot"> 맵에 추가하려는 것과 동일한 키 값이 이미 포함되어 있는 경우 새 값으로 중복 키가 생성되지 않고 이전 값이 대체됩니다.</p><p class="dropspot"> 맵 구조를 만들고 데이터로 채우면 특정 맵 키에서 값을 가져오려면 다음과 같이 됩니다.</p><p class="code">value = ds[? &quot;Name&quot;];</p><p class="dropspot"> 위의 내용은 &quot;Name&quot; 키에서 값을 가져와 변수에 저장하지만 주어진 키가 DS 맵에 없으면 반환되는 값은 다음과 같습니다. <span class="inline">undefined</span>. 기능 사용 여부를 확인할 수 있습니다.<a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">DS 그리드 [# ]</a></p><div class="droptext" data-targetname="drop-down14"><p class="dropspot"> <a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">DS 그리드</a> 의 구문은 다음과 같습니다.</p><p class="code">grid_index[# xpos, ypos]</p><p class="dropspot"> 로 그리드를 생성한 후<span class="inline">ds_grid_create()</span> 함수를 사용하는 경우 변수에 저장한 그리드 인덱스를 사용하여 참조하며 &quot;xpos&quot; 및 &quot;ypos&quot;는 값을 가져오거나 설정하기 위한 그리드 내의 위치입니다. 예를 들어 다음 코드는 그리드를 만들고 0으로 지운 다음 몇 가지 항목을 추가합니다.</p><p class="code">ds = ds_grid_create();<br />
      ds_grid_clear(ds, 0);<br />
      var gw = ds_grid_width(ds) - 1;<br />
      var gh = ds_grid_height(ds) - 1;<br />
      repeat(10)<br />
      {<br />
          var xx = irandom(gw);<br />
          var yy = irandom(gh);<br />
          if (ds[# xx, yy] == 0)<br />
          {<br />
              ds[# xx, yy] = 1;<br />
          }<br />
      }</p><p class="dropspot"> 그리드 구조를 만들고 데이터로 채우면 특정 그리드 위치에서 값을 얻으려면 다음과 같이 됩니다.</p><p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p><p class="dropspot"> 위는 마우스 위치를 기반으로 주어진 ds_grid에서 값을 가져옵니다(정확한 위치를 얻기 위해 방의 &quot;셀&quot; 너비로 나눕니다). 그리드 경계 외부에 있는 위치를 제공하면 값 <span class="inline">undefined</span> 함수 사용을 확인할 수 있는 반환됩니다.<a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">배열 [@ ]</a></p><div class="droptext" data-targetname="drop-down15"><p class="dropspot"> 이 접근자는 <a href="../../Settings/Game_Options.htm">쓰기 시 복사 옵션이 활성화된</a> 경우에만 사용됩니다.</p><p class="dropspot"> 배열에는 데이터 구조에 대해 위에 나열된 것과 유사한 방식으로 작동하는 자체 접근자가 있습니다. 그러나 배열 접근자는 흥미로운 속성을 가지고 있으며 복사할 필요 없이 <a href="Script_Functions.htm">스크립트 함수</a> 또는 <a href="Method_Variables.htm"><span class="notranslate">method</span></a> 에서 배열을 수정할 수 있도록 합니다. 배열을 함수에 전달할 때 <strong>참조로 전달됩니다</strong>. 즉, 배열 자체가 스크립트에 제공되는 것이 아니라 단순히 데이터를 가져오기 위해 참조되는 것입니다. 일반적으로 배열을 변경해야 하는 경우 스크립트에 <em>복사</em> 한 다음 원본 배열이 업데이트되도록 복사한 배열을 다시 전달(반환)해야 합니다. 이것은 비용이 많이 드는 처리 오버헤드를 가질 수 있으므로 복사할 필요 없이 원래 배열 <em>을 직접</em> 변경하므로 접근자를 대신 사용할 수 있습니다. 아래 예에서 이것이 어떻게 작동하는지 확인할 수 있습니다.</p><p class="dropspot"> 다음을 사용하는 배열 구문 <span class="inline">@</span> 접근자는 다음과 같습니다.</p><p class="code">array[@ i]</p><p class="dropspot"> 인스턴스에서 배열을 만든 후 참조로 스크립트에 전달하고 접근자를 사용할 수 있습니다.<span class="inline">@</span> 직접 변경합니다. 예를 들어 배열을 만들고 다음과 같이 함수를 호출합니다.</p><p class="code">array[99] = 0;<br />
      array_populate(array);</p><p class="dropspot"> 함수 자체에는 다음과 같은 내용이 있습니다.</p><p class="code">function array_populate(_array)<br />
      {<br />
          var a = _array; var i = 0; repeat(25)<br />
          {<br />
              i = irandom(99);<br />
              while (a[i] != 0)<br />
              {<br />
                  i = irandom(99);<br />
              }<br />
              a[@ i] = 100;<br />
          }<br />
      }</p><p class="dropspot"> 이 함수가 하는 모든 일은 배열에서 25개의 임의 위치를 선택하고 선택한 배열 위치의 값을 100으로 설정하는 것입니다.</p><p class="dropspot"> 물론, <span class="inline">@</span> <strong>Copy on Write</strong> 가 비활성화된 경우 접근자가 필요하지 않습니다.</p><p class="note"> <span class="note">참고</span> 어레이 접근자를 사용할 수 없습니다. <span class="inline">@</span> 작업할 때<span class="inline">argument[n]</span> 스크립트 함수의 배열.</p><p class="dropspot"></p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">구조체 [$ ]</a></p><div class="droptext" data-targetname="drop-down16"><p class="dropspot"> <span><a href="Structs.htm">구조체</a> 의 구문은 다음과 같습니다.</span></p><p class="code">struct[$ &quot;name&quot;]</p><p class="dropspot"> 이 접근자는 본질적으로 함수에 대한 래퍼입니다. <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> 그리고 <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>, 그리고 DS 맵에 대한 접근자와 매우 유사하게 사용합니다. 예를 들어 구조체를 만들고 &quot;my_health&quot;라는 변수에서 값을 검색하려면 다음을 수행합니다.</span></p><p class="code">var _hp = struct[$ &quot;my_health&quot;];</p><p class="dropspot"> 보시다시피 변수 자체를 제공하지 않고 변수와 함께 <em>문자열</em> 을 제공합니다. 구조체에 주어진 이름의 변수가 없으면 접근자는 다음을 반환합니다. <span class="inline">undefined</span> 값으로.</p><p class="dropspot"> 구조체에서 변수를 설정하려면 다음을 수행합니다.</p><p class="code">struct[$ &quot;my_score&quot;] = 100;</p><p class="dropspot"> 값을 가져올 때와 마찬가지로 문자열로 설정할 변수의 이름을 제공하면 주어진 값으로 설정됩니다. 사용된 변수 이름이 구조체에 존재하지 않으면 생성되어 지정된 값으로 설정됩니다.</p><p class="dropspot"></p></div><p></p><p> 접근자의 중요한 특징은 서로 <i>연결될</i> 수 있다는 사실입니다. 즉, 중첩된 데이터 구조 및/또는 배열이 여러 개 있는 경우 중첩된 구조 내 깊숙한 값에 액세스하기 위해 더 이상 다양한 함수를 사용할 필요가 없습니다. 예를 들어 배열이 있고 배열의 각 항목이 다음과 같이 DS 목록이라고 가정해 보겠습니다.</p><p class="code">array = array_create(3);<br />
    for (var i = 0; i &lt; 3; ++i;)<br />
    {<br />
        array[i] = ds_list_create();<br />
        switch(i)<br />
        {<br />
            case 0:<br />
                with (obj_Wall) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 1:<br />
                with (obj_Door) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 2:<br />
                with (obj_Chest) ds_list_add(array[i], id);<br />
            break;<br />
        }<br />
    }
  </p><p> 위의 코드에서 3개의 항목 배열을 만들고 각각에 DS 목록을 할당한 다음 게임에 있는 다양한 개체의 인스턴스 ID로 다른 목록을 채웠습니다. 이제 목록 중 하나의 ID에 액세스하기 위해 다음을 수행할 수 있습니다.</p><p class="code">var _list = array[0];<br />
    var _id = ds_list_find_value(_list, 0);</p><p> 그러나 더 적은 코드를 사용하는 훨씬 깔끔한 방식으로 연결된 접근자를 사용하여 동일한 작업을 수행할 수 있습니다.</p><p class="code">var _id = array[0][| 0];</p><p> 이러한 방식으로 여러 접근자를 함께 연결할 수 있으며 중첩 구조의 각 부분에 저장된 정보에 액세스하기 위해 여러 유형이 될 수 있습니다. 다음은 몇 가지 예입니다.</p><p class="code">// Access a grid that has been added to a list that is part of a map:<br />
    var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br />
    <br />
    // Access an array nested in a list from a script and modify it:<br />
    data[| 0][@ 10] = 100;<br />
    <br />
    // Access a map nested in a grid nested in a list nested in an array:<br />
    data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;
  </p><p> 사물에 연결된 접근자를 사용하면 더 간결한 코드를 작성할 수 있을 뿐만 아니라 반복을 사용할 수 있습니다(예:<a href="Language_Features/for.htm"><span class="inline">for</span></a> 루프) 및 기타 기술을 사용하여 보다 깨끗하고 직관적인 방식으로 데이터에 액세스할 수 있습니다.</p><p> 이런 식으로 접근자를 사용할 때는 항상 <span class="inline">@</span> 그렇지 않으면 수행 중인 모든 작업에 추가 오버헤드가 추가됩니다. 위에서 언급했듯이 기본적으로 배열은 참조에 의해 함수에 전달된 다음 수정될 때 &quot;쓰기 시 복사&quot; 동작을 사용합니다. 그러나 배열이 체인의 일부인 경우 체인의 이전 항목이 복사된 배열로 업데이트되고 &quot;원본&quot;이 삭제됩니다. 예를 들어 다음과 같이 합니다.</p><p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][0] = 200;
  </p><p> 다음을 수행하는 것과 동일한 결과를 얻습니다.</p><p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][@ 0] = 200;
  </p><p> 그러나 두 번째 예는 전체 어레이를 먼저 복사하는 불필요한 오버헤드 없이 작동하므로 더 좋습니다. </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> 뒤로: <a href="GML_Overview.htm">GML 개요</a></div><div style="float:right"> 다음: <a data-xref="{title}" href="Language_Features.htm">언어 기능</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>