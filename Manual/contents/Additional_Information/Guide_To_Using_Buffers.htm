<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>버퍼 사용 안내</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="버퍼 작동 방식을 설명하는 페이지" />
  <meta name="rh-index-keywords" content="버퍼 사용 안내" />
  <meta name="search-keywords" content="버퍼 사용,버퍼" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> 버퍼 사용 안내</h1><p> (프로그래밍에서) 버퍼는 기본적으로 거의 모든 것에 대한 작은 데이터 패킷을 저장하는 데 사용되는 시스템 메모리 내의 공간입니다(예: 데이터 전송, 충돌, 색상 데이터 등). 시스템 메모리에 저장되기 때문에 액세스가 매우 빠르며 버퍼는 일반적으로 처리하기 전에 네트워크 정보를 수신하거나 게임에 체크포인트를 저장하는 것과 같은 매우 단기 저장에 사용됩니다(이는 페이지 아래에 추가로 제공된 예).</p><p><img alt="Buffer Memory" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Buffer_Memory.png" /> 버퍼는 <a class="glossterm" data-glossterm="바이트" href="#">bytes 단위</a> <span class="glossextra">로</span> 계산된 시스템 메모리에 공간을 할당하여 생성되며, 게임이 실행되는 동안 또는 적절한 기능을 사용하여 버퍼를 삭제할 때까지 게임을 위해 예약됩니다(모든 GML 버퍼 기능을 찾을 수 있습니다. <a href="../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">여기</a> 에 나열됨). 즉, 게임에 초점이 맞지 않는 경우에도(예: 모바일 장치에서 전화를 받으면 게임이 백그라운드로 전환됨) 버퍼는 여전히 존재하지만 게임이 닫히거나 다시 시작되는 경우 버퍼가 손실됩니다.</p><p class="note"> <strong>참고</strong>: 게임을 다시 시작해도 버퍼가 지워지거나 삭제되지 않습니다! 그러나 ID 핸들이 손실되어 결국 게임을 충돌시키는 메모리 누수를 일으키기 때문에 이전에 생성된 버퍼에 대한 추가 액세스를 방지합니다. 따라서 게임을 다시 시작할 때 먼저 버퍼를 삭제하는 것을 잊지 마십시오.</p><p> <span data-keyref="GameMaker Name">GameMaker</span> 는 4가지 다른 버퍼 유형 생성을 허용합니다. 그 이유는 버퍼가 고도로 최적화된 임시 저장 매체로 설계되었기 때문에 저장하려는 데이터 유형에 적합한 버퍼를 생성해야 하기 때문입니다. 그렇지 않으면 오류가 발생하거나 병목 현상이 발생할 수 있습니다. 당신의 코드에서. 더 자세히 설명하기 전에 사용 가능한 4가지 버퍼 유형(GML에서 <strong>상수</strong> 로 정의됨)을 살펴보겠습니다.</p><p></p><table><tbody><tr><th> 일정한</th><th> 설명</th></tr><tr><td><span class="notranslate"><span class="inline">buffer_fixed</span></span></td><td><br /> 고정 크기(바이트)의 버퍼입니다. 크기는 버퍼가 생성될 때 설정되며 다시 변경할 수 없습니다.</td></tr><tr><td><span class="notranslate"><span class="inline">buffer_grow</span></span></td><td><br /> 데이터가 추가될 때 동적으로 <i>증가</i> 하는 버퍼입니다. 초기 크기(저장될 것으로 예상되는 데이터 크기와 비슷해야 함)로 생성한 다음 이 초기 크기를 초과하는 추가 데이터를 허용하도록 확장됩니다.</td></tr><tr><td><span class="notranslate"><span class="inline">buffer_wrap</span></span></td><td><br /> 데이터가 <i>래핑</i> 될 버퍼입니다. 추가되는 데이터가 버퍼 크기의 한계에 도달하면 덮어쓰기가 버퍼의 시작 부분에 다시 배치되고 그 지점부터 추가 쓰기가 계속됩니다.</td></tr><tr><td><span class="notranslate"><span class="inline">buffer_fast</span></span></td><td><br /> 이것은 읽기/쓰기가 매우 빠른 특별한 &quot;제거된&quot; 버퍼입니다. 그러나 다음과 함께만 사용할 수 있습니다. <span class="inline"><span class="inline">buffer_u8</span> 데이터 유형이며 1바이트로 정렬되어야 합니다. ( <b>데이터 유형</b> 및 <b>바이트 정렬</b> 에 대한 정보는 이 페이지 아래에서 찾을 수 있습니다.)</td></tr></tbody></table><p></p><p> 이것들은 <span data-keyref="GameMaker Name">GameMaker</span> 를 사용할 때 사용할 수 있는 버퍼 유형이며 선택하는 버퍼 유형은 사용하려는 용도에 따라 크게 달라집니다. 예를 들어, 저장 게임을 생성하기 위해 데이터의 &quot;스냅샷&quot;을 저장하는 데 성장 버퍼가 사용됩니다. 저장 게임에 넣을 실제 데이터 양을 모르기 때문입니다. 예를 들어 이미지에서 <a class="glossterm" data-glossterm="ARGB" href="#">ARGB</a> 데이터를 처리할 때 작업 중인 값이 모두 0과 255 또는 -128과 127 사이임을 알고 있습니다.</p><p><img alt="Buffer Types" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Buffer_Types.png" /> 버퍼를 생성할 때는 항상 유형에 적합한 크기로 생성하도록 시도해야 하며 일반적으로 저장할 데이터의 최대 크기를 수용할 수 있도록 생성해야 하며 확실하지 않은 경우, 덮어쓰기 오류를 방지하기 위해 성장 버퍼를 사용합니다.</p><p> 버퍼를 생성하는 실제 코드는 다음과 같습니다.</p><p class="code">player_buffer = buffer_create(16384, buffer_fixed, 2);</p><p><br /> 그러면 나중에 이 버퍼를 참조하기 위해 변수에 저장된 고유 ID 값을 반환하는 함수와 함께 16384바이트의 고정 버퍼가 생성되고 2로 바이트 정렬됩니다.</p><p> 버퍼에 데이터를 읽고 쓸 때 &quot;데이터 유형&quot;에 의해 정의된 데이터 &quot;청크&quot;에서 수행합니다. &quot;데이터 유형&quot;은 기록 중인 값에 대해 버퍼 내에 할당된 바이트 수를 설정하며, 이를 올바르게 얻는 것이 중요합니다. 그렇지 않으면 코드에 대해 매우 이상한 결과(또는 오류)가 발생할 수 있습니다.</p><p> 버퍼는 <strong>순차적으로</strong> 쓰여지고(읽기 시작), 한 데이터 조각이 다른 데이터 조각 다음에 쓰여지고 각 데이터 조각은 세트 유형이 됩니다. 즉, 항상 버퍼에 쓰는 데이터가 무엇인지 이상적으로 알고 있어야 합니다. 이러한 데이터 유형은 GML에서 다음 상수로 정의됩니다.</p><p></p><table><tbody><tr><th> 데이터 유형 상수</th><th> 바이트</th><th> 설명</th></tr><tr><td><span class="inline">buffer_u8</span></td><td> 1</td><td><br /> 부호 없는 8비트 정수입니다. 0에서 255 사이의 양수 값입니다.</td></tr><tr><td><span class="inline">buffer_s8</span></td><td> 1</td><td><br /> 부호 있는 8비트 정수입니다. -128에서 127 사이의 양수 또는 음수 값일 수 있습니다(0은 양수로 분류됨).</td></tr><tr><td><span class="inline">buffer_u16</span></td><td> 2</td><td><br /> 부호 없는 16비트 정수입니다. 0 - 65,535 사이의 양수 값입니다.</td></tr><tr><td><span class="inline">buffer_s16</span></td><td> 2</td><td><br /> 부호 있는 16비트 정수입니다. 이것은 -32,768에서 32,767 사이의 양수 또는 음수 값일 수 있습니다(0은 양수로 분류됨).</td></tr><tr><td><span class="inline">buffer_f16</span></td><td> 2</td><td><br /> 16비트 부동 소수점 숫자입니다. +/- 65504 범위 내에서 양수 또는 음수 값일 수 있습니다. <b>(현재 지원되지 않습니다!)</b></td></tr><tr><td><span class="inline">buffer_u32</span></td><td> 4</td><td><br /> 부호 없는 32비트 정수입니다. 0에서 4,294,967,295 사이의 양수 값입니다.</td></tr><tr><td><span class="inline">buffer_s32</span></td><td> 4</td><td><br /> 부호 있는 32비트 정수입니다. 이것은 -2,147,483,648에서 2,147,483,647 사이의 양수 또는 음수 값일 수 있습니다(0은 양수로 분류됨).</td></tr><tr><td><span class="inline">buffer_f32</span></td><td> 4</td><td><br /> 32비트 부동 소수점 숫자입니다. +/-16777216 범위 내에서 양수 또는 음수 값일 수 있습니다.</td></tr><tr><td><span class="inline">buffer_u64</span></td><td> 8</td><td><br /> 64비트 부호 없는 정수 값입니다. <b>(현재 모든 버퍼 기능에서 지원되지는 않습니다!)</b></td></tr><tr><td><span class="inline">buffer_f64</span></td><td> 8</td><td><br /> 64비트 부동 소수점 숫자입니다.</td></tr><tr><td><span class="inline">buffer_bool</span></td><td> 1</td><td><br /> 부울 값입니다. 1 또는 0(<span class="inline">true</span> 또는 <span class="inline">false</span> )</td></tr><tr><td><span class="inline">buffer_string</span></td><td> 해당 없음</td><td><br /> 이것은 UTF-8 null로 끝나는(0x00) 문자열입니다. 기본적으로 GameMaker 문자열은 버퍼에 덤프되고 끝에 0이 놓입니다.</td></tr></tbody></table><p></p><p> 따라서 버퍼를 생성하고 여기에 정보를 기록하려는 경우 다음 코드와 같은 것을 사용합니다.</p><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br />
    buffer_write(buff, buffer_bool, global.Music);<br />
    buffer_write(buff, buffer_s16, obj_Player.x);<br />
    buffer_write(buff, buffer_s16, obj_Player.y);<br />
    buffer_write(buff, buffer_string, global.Player_Name);</p><p> 위의 예를 보면 다른 유형의 데이터를 동시에 버퍼에 쓸 수 있음을 알 수 있습니다( <em>고속</em> 버퍼 유형을 사용할 때 특정 데이터 유형으로만 제한됨). 이 데이터는 버퍼에 추가됩니다 (버퍼에서의 실제 위치는 바이트 정렬에 따라 다르지만 아래에 설명되어 있음). 이것은 버퍼에서 정보를 읽는 경우에도 동일하며 위에 제공된 예의 경우 데이터를 쓴 것과 동일한 순서로 버퍼에서 읽고 동일한 데이터 유형을 확인합니다. 예:</p><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br />
    global.Music = buffer_read(buff, buffer_bool);<br />
    obj_Player.x = buffer_read(buff, buffer_s16);<br />
    obj_Player.y = buffer_read(buff, buffer_s16);<br />
    global.Player_Name = buffer_read(buff, buffer_string);</p><p> 보시다시피 정보를 버퍼로 읽는 것과 같은 순서로 정보를 읽습니다. 버퍼에서 데이터를 추가하고 제거하는 방법에 대한 자세한 내용은 아래 제공된 예를 참조하십시오.</p><p> 이 페이지를 읽었다면 버퍼의 <strong>바이트 정렬</strong> 에 대한 참조를 보았을 것입니다. 이것은 기본적으로 주어진 버퍼 내에서 새 데이터가 저장될 위치를 나타냅니다. 어떻게 작동합니까? 음, 단일 바이트 정렬 버퍼의 경우 각 데이터 조각은 버퍼에 순차적으로 기록되며 각 새 데이터 조각은 이전 데이터 조각 바로 다음에 추가됩니다. 그러나 2바이트로 정렬된 버퍼는 각 데이터 조각을 2바이트 간격으로 쓰기 때문에 초기 쓰기가 1바이트 데이터인 경우에도 다음 쓰기는 2바이트로 정렬되도록 이동됩니다.</p><p><img alt="Buffer Byte Alignment" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Buffer_Byte_Alignment.png" /> 따라서 바이트 정렬이 예를 들어 4바이트로 설정되어 있고 크기가 1바이트인 단일 데이터 조각을 작성하는 경우 버퍼 <strong>텔</strong> 을 수행합니다(텔링은 버퍼에 대한 읽기/쓰기의 현재 위치를 가져옴). 1바이트의 <strong>오프셋</strong> 을 얻게 됩니다(이 경우 오프셋은 버퍼의 시작부터 현재 읽기/쓰기 위치까지의 바이트 수입니다).</p><p> 그러나 크기가 1바이트인 다른 데이터 조각을 작성한 <em>다음</em> 버퍼 지시를 수행하면 정렬이 데이터를 채웠기 때문에 5바이트의 오프셋을 얻게 됩니다(2바이트의 데이터만 작성했음에도 불구하고). 4바이트 버퍼 정렬로 정렬합니다.</p><p> 기본적으로 이것이 의미하는 바는 정렬이 항목이 기록 <em>되는 위치</em> 에만 영향을 미치므로 무언가를 작성한 후 버퍼 텔을 수행하면 이전에 작성한 데이터 바로 다음에 오는 현재 쓰기 위치가 반환된다는 것입니다. 그러나 다른 데이터 조각을 쓰는 경우 내부적으로 버퍼는 데이터 조각을 실제로 쓰기 전에 정렬 크기의 다음 배수로 쓰기 위치를 이동합니다.</p><p> 아래에는 프로젝트에서 버퍼를 사용하는 방법에 대한 몇 가지 예가 있습니다.</p><p></p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">버퍼 체크포인트</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot"> 모든 플랫폼의 <span data-keyref="GameMaker Name">GameMaker</span> 게임에서 버퍼를 사용하는 방법에 대한 간단한 예는 다음과 같습니다. <a href="../GameMaker_Language/GML_Reference/General_Game_Control/game_save_buffer.htm"><span class="inline">game_save_buffer()</span></a>. 이 함수는 현재 게임 상태의 &quot;스냅샷&quot;을 가져와 미리 정의된 버퍼에 저장합니다. 그런 다음 해당 지점에서 게임을 다시 로드하기 위해 읽을 수 있습니다.</p><p class="note"> <strong>참고</strong>: 이 기능은 매우 제한적이며 초보자가 체크포인트 시스템을 빠르게 시작하고 실행할 수 있도록 설계되었지만 고급 사용자는 게임이 저장되지 않는다는 사실 때문에 파일 기능을 사용하여 자신의 시스템을 코딩하는 것을 선호할 수 있습니다. 데이터 구조, 표면, 추가된 스프라이트 등과 같이 런타임에 생성할 수 있는 모든 동적 리소스...</p><p class="dropspot"> 가장 먼저 해야 할 일은 저장 및 로드를 제어하는 새 개체를 만드는 것이므로 하나 만들고 <strong>이벤트 만들기</strong> 를 제공합니다. 이 경우 다음 코드를 배치할 수 있습니다.</p><p class="code">SaveBuffer = buffer_create(1024, buffer_grow, 1);<br />
      StateSaved = false;</p><p class="dropspot"> 첫 번째 줄은 1024바이트의 성장 버퍼(저장된 데이터의 최종 크기를 모르기 때문에)를 만들고 1바이트로 정렬합니다. 그런 다음 게임이 저장되었는지 여부를 확인하고 확인하기 위해 변수가 생성됩니다(로드에 사용됨).</p><p class="dropspot"> 다음으로 현재 게임 상태를 생성된 버퍼에 저장하는 <strong>Keypress 이벤트</strong> (예:)를 추가합니다.</p><p class="code">StateSaved = true;<br />
      buffer_seek(SaveBuffer, buffer_seek_start, 0);<br />
      game_save_buffer(SaveBuffer);</p><p class="dropspot"> 위는 먼저 제어 변수를 다음으로 설정합니다. <span class="inline">true </span> (게임을 버퍼에 저장할 때 저장되도록) 그런 다음 현재 저장 상태를 버퍼에 쓰기 전에 버퍼의 시작 부분을 찾습니다. 우리가 사용하는 이유 <a href="../GameMaker_Language/GML_Reference/Buffers/buffer_seek.htm"><span class="inline">buffer_seek()</span></a> ? 이 페이지에서 이미 언급했듯이 데이터가 추가된 마지막 위치에서 버퍼를 읽고 씁니다. 즉, 버퍼 텔백을 시작으로 설정하지 않으면 저장할 때 현재 버퍼 읽기/쓰기 위치에서 버퍼에 데이터를 추가하게 됩니다. 그래서 우리는 함수를 사용합니다. <span class="inline">buffer_seek()</span> 텔을 버퍼 시작으로 이동합니다.</p><p class="dropspot"> 이제 현재 게임 상태를 버퍼에 저장했습니다. 다음 단계는 아마도 다른 <strong>Keypress 이벤트</strong> 에서 로드하는 방법을 코딩하는 것입니다.</p><p class="code">if StateSaved<br />
      {<br />
          buffer_seek(SaveBuffer, buffer_seek_start, 0);<br />
          game_load_buffer(SaveBuffer);<br />
      }</p><p class="dropspot"> 그런 다음 위의 코드를 배치한 이벤트가 끝날 때 게임이 로드됩니다.</p><p class="note"> <strong>참고</strong>: 이것은 같은 방에서만 사용하기 위한 것이며 게임을 종료하거나 다시 시작한 후 저장한 게임을 완전히 생성하기 위한 것은 아닙니다!</p><p class="dropspot"> 컨트롤러 개체에 마지막으로 추가할 것은 &quot;정리&quot; 코드입니다. 버퍼는 메모리에 저장되므로 버퍼 사용을 마친 후 정리하지 않으면 메모리 누수가 발생하여 결국 게임이 지연되고 충돌이 발생할 수 있습니다. 따라서 다음을 사용하여 <strong>회의실 종료 이벤트</strong> ( <strong>기타</strong> 이벤트 범주에서)를 추가할 수 있습니다.</p><p class="code">buffer_delete(SaveBuffer);</p><p class="dropspot"> 이제 이 개체를 방에 배치하고 키를 누르면 버퍼에서 방 상태를 저장하고 로드할 수 있습니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">네트워크 버퍼</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot"> <span data-keyref="GameMaker Name">GameMaker</span> <a href="../GameMaker_Language/GML_Reference/Networking/Networking.htm">네트워킹 기능</a> 으로 작업할 때 버퍼를 사용하여 네트워크 연결을 통해 전송되는 데이터 패킷을 생성해야 합니다. 이 예제는 이것이 어떻게 수행되는지 보여주기 위한 것이지만 네트워킹 가능성의 범위로 인해 전체 네트워킹 시스템이 아니라 버퍼 자체를 사용하는 방법을 보여주기 위한 것일 뿐입니다.</p><p class="dropspot"> 가장 먼저 보여줄 것은 네트워크 연결의 클라이언트 측을 위한 버퍼 생성 및 사용입니다. 이 버퍼는 서버로 보낼 수 있는 작은 데이터 패킷을 만드는 데 사용되므로 인스턴스의 <strong>이벤트 만들기</strong> 에서 다음과 같은 버퍼를 할당합니다.</p><p class="code">send_buff = buffer_create(256, buffer_grow, 1);</p><p class="dropspot"> 우리는 버퍼를 작게 만듭니다(256바이트) - 많은 양의 데이터를 보유하기 위한 것이 아니므로 - 그런 다음 언제든지 보낼 데이터를 더 추가해야 할 때 오류가 없도록 확장 버퍼로 만들고 정렬합니다. 편의상 1로 설정했습니다.</p><p class="dropspot"> 이제 클라이언트가 서버에 데이터를 보내길 원한다고 가정해 보겠습니다. 이를 위해 버퍼 &quot;패킷&quot;을 생성해야 하며, 이 예에서는 플레이어가 게임 주변을 이동하기 위해 <em>왼쪽 화살표</em> 를 누를 때와 같이 <strong>Key Press Event</strong> 를 보낼 것입니다. 이를 수행하기 위해 먼저 필요한 데이터를 버퍼에 쓴 다음 전송합니다.</p><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br />
      buffer_write(buff, buffer_u8, 1);<br />
      buffer_write(buff, buffer_s16, vk_left);<br />
      buffer_write(buff, buffer_bool, true);<br />
      network_send_packet(client, buff, buffer_tell(buff));</p><p class="dropspot"> 버퍼에 쓰기 전에 네트워킹이 항상 버퍼의 시작 부분에서 데이터를 가져오기 때문에 &quot;tell&quot;을 버퍼의 시작 부분으로 설정했습니다. 그런 다음 확인 값(서버에서 처리할 이벤트 유형을 결정하는 데 사용됨), 사용 중인 키, 키 상태(이 경우 눌림에 대해 true)를 작성합니다. 이 버퍼는 네트워크 기능에 의해 데이터 패킷으로 전송됩니다. 전체 버퍼를 보내지 않는다는 점에 유의하십시오! 버퍼의 현재 읽기/쓰기 위치를 반환하기 위해 buffer_tell 함수를 사용하여 쓰여진 데이터만 보냅니다(버퍼에 쓰기는 쓰여진 것의 끝으로 &quot;tell&quot;을 이동한다는 것을 기억하십시오). 이것은 단순히 필요한 것보다 더 많은 바이트를 보내는 것을 피하기 위한 것입니다.</p><p class="dropspot"> 서버에서 데이터를 수신하는 것은 어떻습니까? 서버의 버퍼에 기록된 다음 게임을 업데이트하는 데 사용되어야 하는 수신된 데이터 패킷입니다. 이를 위해 아래의 단순화된 코드에서 볼 수 있듯이 서버의 네트워크 컨트롤러 개체에서 <a href="../The_Asset_Editors/Object_Properties/Async_Events.htm">네트워킹 비동기 이벤트</a> 를 사용합니다.</p><p class="code">var buff = ds_map_find_value(async_load, &quot;buffer&quot;);<br />
      if cmd == buffer_read(buff, buffer_u8);<br />
      {<br />
          key = buffer_read(buff, buffer_s16);<br />
          key_state = buffer_read(buff, buffer_bool);<br />
      }</p><p class="dropspot"> 비동기식 이벤트에는 특별한 임시 DS 맵이 포함됩니다. <span class="inline">async_load</span> (이벤트가 끝나면 메모리에서 자동으로 제거됨) 네트워크에서 들어오는 데이터의 유형에 따라 다른 정보를 포함합니다. 이 경우 맵이 확인되었고 클라이언트에서 보낸 버퍼 데이터 패킷인 것으로 가정합니다. 이제 버퍼에 있는 첫 번째 데이터 조각을 확인하여 어떤 종류의 이벤트가 전송되었는지 확인합니다. 이 경우 값 &quot;1&quot;은 주요 이벤트를 나타냅니다. 그러나 이러한 항목을 코딩할 때 이러한 값을 저장할 상수를 정의해야 합니다. 일을 단순화하고 누른 키와 상태를 저장합니다(<span class="inline">true</span> = 눌렀다, <span class="inline">false</span> = 해제됨). 그런 다음 이 정보는 보내는 클라이언트 플레이어의 새 상태로 모든 클라이언트를 업데이트하는 데 사용됩니다.</p><p class="note"> <strong>참고</strong>: DS 맵에서 생성된 버퍼는 네트워크 비동기 이벤트가 종료되면 자동으로 제거되므로 여기서 <span class="inline" style="font-size: 14px">buffer_delete()</span> 를 사용할 필요가 없습니다. </p><p class="dropspot"></p></div><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> 뒤로: <a href="Additional_Information.htm">추가 정보</a></div><div style="float:right"> 다음: <a href="Bitwise_Operators.htm">비트 연산자</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2021 판권 소유</span></h5>
  </div>
  <!-- KEYWORDS
Buffers
Using Buffers
-->
  <!-- TAGS
using_buffers
-->
</body>
</html>