<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>프로그래밍 시 모범 사례</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="GameMaker를 사용하여 프로그래밍할 때 몇 가지 모범 사례를 설명하는 페이지" />
  <meta name="rh-index-keywords" content="프로그래밍 시 모범 사례" />
  <meta name="search-keywords" content="모범 사례" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> 프로그래밍 시 모범 사례</h1><p> 이 페이지에서 우리는 게임을 프로그래밍할 때 몇 가지 &quot;모범 사례&quot;를 다룰 것이며 동시에 <span data-keyref="GameMaker Name">GameMaker</span> 의 내부 작동에 대해 약간 설명할 것입니다. 그러나 계속하기 전에 다음 두 가지 매우 중요한 사항에 주목할 필요가 있습니다.</p><ul class="colour"><li> 이것은 <em>가이드</em> 일 뿐이며 게임을 작성하는 100% 완벽한 방법은 아닙니다! 여기에 언급된 내용은 일반적으로 조직적 및 미시적 최적화 규모에 더 가깝고 GML이 편안하고 적절하다고 생각할 때 프로그래밍 습관에 통합해야 합니다.</li><li> 게임이 잘 실행되고 있는 그대로 만족 <em>한다면 몇 가지 추가 FPS를 짜기 위해 모든 것을 변경하려고 서두르지 마십시오</em>. 읽기 쉽고 유연하며 모듈식 코드를 변경하는 데 필요한 시간과 에너지, 그리고 결국 전체 이득 사이에서 균형을 유지해야 합니다. 기본적으로 고장나지 않았다면 고치지 말고 다음 프로젝트를 위해 여기에서 배운 내용을 유지하세요.</li></ul><p> 즉, 언제든지 적용할 수 있는 좋은 GML 코드를 작성하기 위한 몇 가지 일반적인 팁을 살펴보겠습니다.</p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">프로그래밍 스타일</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot"> 코드 작성과 관련하여 누구나 <em>스타일</em> 이 있습니다. 프로그래밍 스타일은 대괄호를 배치하는 방법, 줄을 들여쓰는 방법, 변수를 선언하고 이름을 지정하는 방법 등이며 다른 사람들(그리고 미래의 자신, 다른 일을 한 후에 이 프로젝트로 돌아와야 할 때).</p><p class="dropspot"> 많은 <a href="http://en.wikipedia.org/wiki/Programming_style">프로그래밍 스타일</a> 이 있으며 일부는 자신의 것이 사용하기에 가장 좋은 스타일이라고 주장하지만 진실은 사용할 때 <strong>일관성</strong> 이 있고 모든 것이 무엇인지 <em>명확</em> 하고 <em>분명</em> 하다면 거의 모든 스타일이 괜찮다는 것입니다. 하다.</p><p class="dropspot"><img alt="Code Style Example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Style_Example.png" /> 위 이미지는 위의 사항을 설명하기 위한 스크립트 내 함수 선언 예시입니다. JSDoc 스타일 주석을 사용하여 모든 기능을 명확하게 설명하고 코딩 스타일이 일관적이며 4개의 공백 들여쓰기, 로컬 변수에 사용되는 밑줄, 기록된 출력 등을 볼 수 있습니다.</p><p class="dropspot"> 또한 스크립트 편집기에서 각 열기/닫기 대괄호에서 코드를 접을 수 있지만 다음을 사용할 수 있습니다. <span class="inline">#region</span> 그리고 <span class="inline">#endregion</span> 태그를 사용하여 코드의 일부를 구분하고 특히 여러 기능을 포함하는 더 큰 스크립트를 처리할 때 가독성을 크게 향상시킵니다. 지역도 주석을 달 수 있습니다 - 매뉴얼에서 이 페이지의 편집 섹션을 참조하십시오):</p><p class="dropspot"><img alt="Example Of Using Regions" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Regions.png" /> 코드를 작성할 때 최종 게임을 컴파일할 때 <span data-keyref="GameMaker Name">GameMaker</span> 는 주석을 제거하고 불필요한 줄 바꿈과 공백을 제거하고 상수/매크로/열거형 값을 대체하고 일반적으로 프로세스의 일부로 코드를 압축한다는 점을 알고 있어야 합니다. 즉, 코드 주위에 필요한 만큼 공백을 추가할 수 있으며 주석을 짧게 유지하거나 드물게만 사용하는 것에 대해 걱정할 필요가 없습니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">지역 변수 사용</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot"> 프로그래밍 스타일에 대한 위의 요점에서 계속해서 많은 초보자가 하는 것 중 하나는 가능한 한 한 줄의 코드에 많은 것을 집어 넣는 것입니다. 예를 들어:</p><p class="code">draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y)));</p><p class="dropspot"> 완전히 읽을 수 없는 것은 아니지만 비효율적입니다( <span class="inline">point_direction()</span> 예를 들어 함수가 두 번 호출됨) 보기에 지저분하고 어색합니다. 다음과 같이 표현하는 것이 훨씬 더 나을 것입니다.</p><p class="code">var p_dir = point_direction(x, y, mouse_x, mouse_y);<br />
      var local_x = x + lengthdir_x(100, p_dir);<br />
      var local_y = y + lengthdir_y(100, p_dir);<br />
      draw_sprite(sprite_index, image_index, local_x, local_y);</p><p class="dropspot"> 이러한 로컬 변수를 생성하는 데 필요한 메모리와 리소스는 무시할 수 있으며 명확성에서 얻는 즉각적인 이점(또는 나중에 코드를 읽는 다른 사람)보다 훨씬 중요합니다. 함수에도 동일한 아이디어를 적용해야 합니다. 입력 변수에 적절한 이름을 할당하고 가능한 한 읽기 쉽게 만들기 위해 필요한 경우 명확한 형식과 지역 변수를 사용해야 합니다.</p><p class="dropspot"> 로컬 변수는 게임 내에서 빠르게 처리되므로 최대한 활용하고, 코드 블록이나 스크립트에 표현식이 두 번 이상 나타나면 이에 대한 로컬 변수 생성을 고려하십시오. <a class="glossterm" data-glossterm="YoYo 컴파일러(YYC)" href="#">YoYo Compiler(YYC)</a> 대상을 사용할 때 <span class="inline">global</span> 또는 함수 또는 코드 블록에서 여러 번 인스턴스 변수를 사용하는 경우 코드 시작 부분에서 로컬 변수에 할당한 다음 해당 로컬 변수를 참조하는 것이 특히 유용합니다. 이렇게 하면 훨씬 더 나은 성능을 얻을 수 있기 때문입니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">배열</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"> <a href="../GameMaker_Language/GML_Overview/Arrays.htm">배열</a> 은 사용이 빠르고 데이터 구조보다 메모리가 덜 필요하지만 더 최적화할 수 있습니다. 배열을 생성할 때 크기에 따라 메모리가 할당되므로 나중에 채울 계획이 없더라도 배열을 최대 크기로 먼저 초기화해야 합니다. 예를 들어, 최대 100개의 값을 보유하기 위해 배열이 필요하다는 것을 알고 있다면 다음을 사용하여 즉시 100개의 슬롯으로 초기화합니다. <a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> 기능:</p><p class="code">array = array_create(100, 0);</p><p class="dropspot"> 이것은 모든 배열 값이 기본값 0으로 설정된 하나의 &quot;청크&quot;에 메모리를 할당하고 빠르게 유지하는 데 도움이 됩니다. 그렇지 않으면 배열에 새 값을 추가할 때마다 전체 메모리를 다시 할당해야 하기 때문입니다. 다시.</p><p class="note"> <span class="note">참고</span> HTML5 대상에서 이와 같은 배열을 할당하는 것은 적용되지 않으며 이 대상에 대해 배열을 0에서 초기화해야 합니다! 예를 들어 os_browser 변수를 확인하여 이를 쉽게 처리할 수 있습니다.</p><p class="code"><span style="padding-left:1px;">if (os_browser == browser_not_a_browser)<br />
        {<br />
            array_create(100, 0);<br />
        }<br />
        else<br />
        {<br />
            for (var i = 0; i &lt; 100; ++i)<br />
            {<br />
                array[i] = 0;<br />
            }<br />
        }</span></p><p class="dropspot"> 사용된 변수를 0으로 설정하여 배열과 관련된 메모리를 확보할 수도 있습니다. 따라서 위의 코드 예제에서 배열을 지우려면 다음을 사용하기만 하면 됩니다.</p><p class="code">array = 0;</p><p class="dropspot"> 또한 배열은 <strong>참조로 전달</strong> 되지만 변경이 있을 때 전체를 복사합니다(이 동작 <strong>을 쓰기 시 복사</strong> 라고 함). 따라서 배열을 함수에 전달하면 원래 배열에 <em>대한 참조</em> 를 전달하는 것이며 여기에서 읽은 모든 값은 원래 소스에서 가져옵니다. 이것은 훌륭하고 빠르지만 배열 값을 수정해야 하는 경우 쓰기 시점에서 배열 자체가 복제되고 변경된 사항 <strong>은 함수에서 반환되어야 하며 그렇지 않으면 손실됩니다</strong>. 이것은 훨씬 느리고 더 많은 메모리를 소비하므로 함수에서 배열을 사용하는 방법에 주의하십시오.</p><p class="dropspot"> 그러나 특수 배열 <a href="../GameMaker_Language/GML_Overview/Accessors.htm">접근자를</a> 사용하여 쓰기 시 복사 동작을 피할 수 있습니다.<span class="inline">@</span>, 기본 배열에 직접 액세스할 수 있기 때문입니다. 예를 들어:</p><p class="code">// Call a function, passing our array<br />
      my_function(my_array);</p><p class="code">// The function looks like this:<br />
      <br />
      function my_function(_a)<br />
      {<br />
          // The array will be copied and the copy modified,<br />
          // requiring you to use &quot;return _a&quot;, later<br />
          _a[0] = 100;<br />
      <br />
          // This will modify the ORIGINAL array directly and<br />
          // does not require it to be returned<br />
          _a[@ 0] = 100;<br />
      }
    </p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">데이터 구조</a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot"> <span data-keyref="GameMaker Name">GameMaker</span> 에서 <a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">데이터 구조</a> 는 이전 GameMaker 버전보다 훨씬 빠르게 최적화되었습니다. 메모리를 해제하는 데 사용하지 않을 때는 여전히 정리(파기)해야 하며, 예를 들어 배열보다 여전히 느릴 수 있지만 사용 용이성과 포함된 데이터를 처리하기 위한 추가 기능이 종종 더 중요할 수 있습니다. 최소한의 속도 차이이므로 게임에서 사용하는 것을 두려워하지 마십시오.</p><p class="dropspot"> 모든 데이터 구조 중에서 특히 DS Maps는 읽기와 쓰기가 모두 빨라 모든 유형의 작업에 탁월한 옵션이 됩니다.</p><p class="dropspot"> 이전에 배열에 대한 <a href="../GameMaker_Language/GML_Overview/Accessors.htm">접근</a> 자를 언급했지만 데이터 구조에도 사용할 수 있으므로 코드를 정리하고 읽기가 훨씬 쉬워집니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">충돌</a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot"> <span data-keyref="GameMaker Name">GameMaker</span> 에서 <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">충돌을 처리하는 방법은 여러 가지가</a> 있으며 대부분은 약간의 추가 CPU 오버헤드가 추가됩니다. 그만큼 <span class="inline">collision_</span> 그리고 <span class="inline">point_</span> 기능, <span class="inline">place_</span> 기능 및 <span class="inline">instance_</span> 기능은 모두 방 내에서 주어진 유형의 모든 인스턴스에 대한 <a class="glossterm" data-glossterm="경계 상자" href="#">경계 상자</a> 검사에 의존하며 이러한 검사를 제한하기 위해 엔진에 내장된 일부 최적화가 있지만 충돌은 처리하기에 가장 효율적인 것은 아닙니다. 정확한 충돌을 사용하기 시작하면 경계 상자 검사를 수행할 뿐만 아니라 실제로 매우 느린 픽셀 단위 검사도 수행하므로 성능도 눈에 띄게 악화됩니다.</p><ul class="dropspotlist"></ul><p class="dropspot"> 그렇다고 해서 이러한 기능을 사용하면 안 된다는 것은 아닙니다. 매우 편리할 수 있기 때문입니다. 그러나 모두 약간 다르게 작동하고 다른 속도를 가지므로 어느 것을 언제 사용해야 하는지 알아야 합니다. 대략적인 경험 법칙은 <span class="inline">place_</span> 기능은 보다 빠릅니다. <span class="inline">instance_</span> 보다 빠른 기능을 제공합니다. <span class="inline">collision_</span> 그리고 <span class="inline">point_</span> 기능이 있으므로 각 기능 유형에 대한 설명서의 페이지를 읽고 모든 상황에 가장 적합한 기능을 선택하십시오.</p><p class="dropspot"> 또는 타일 <a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">맵 기능</a> 이나 사용자 정의 2D 어레이 또는 DS 그리드를 사용하여 생성할 수 있는 <strong>타일 기반 충돌 시스템</strong> 생성을 살펴보십시오. 이것은 매우 빠르며 게임 속도를 높이는 데 도움이 됩니다. 그러나 불규칙한 지형이나 벽과 격자에 정렬되지 않은 물체를 사용하는 경우 적절하지 않을 수 있습니다. 다음 비디오 링크에서 타일맵 충돌에 대한 매우 간단한 자습서를 찾을 수 있습니다.</p><ul class="dropspotlist"><li class="dropspot"> <a href="https://youtu.be/UyKdQQ3UR_0"><span data-keyref="GameMaker Name">GameMaker의</span> 타일 충돌</a></li></ul><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#">텍스처 스왑 및 정점 배치</a></p><div class="droptext" data-targetname="drop-down5"><p class="dropspot"> <a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>디버그 오버레이</strong></a> 를 켜면 테스트할 때 화면 상단의 대괄호 안에 두 개의 그림이 있는 것을 볼 수 있습니다. 첫 번째는 수행 중인 <strong>텍스처 스왑</strong> 의 수이고 두 번째는 <strong>정점 배치</strong> 의 수입니다. 많은 요인이 이 수치에 영향을 미치며 엔진이 각 단계마다 하나 또는 두 개를 필요로 하므로 절대 (0)(0)으로 낮추지 않을 것이지만 이러한 값을 가능한 한 낮추는 것을 목표로 해야 합니다.</p><p class="dropspot"><img alt="The Debug Overlay Bar" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractices_DebugOverlay.png" /> 텍스처 스왑의 경우 가장 효율적이고 효과적인 방법은 스프라이트와 배경이 텍스처 페이지에 저장되는 방식을 최적화하는 것입니다. 이것은 <a href="../The_Asset_Editors/Sprites.htm">스프라이트 속성</a> 에서 수행되며 <a href="../Settings/Texture_Groups.htm">텍스처 그룹 편집기</a> 에서 텍스처 페이지를 만들 수 있습니다. 예를 들어 주 메뉴에서만 사용되는 이미지가 여러 개 있는 경우 별도의 <a href="../Settings/Texture_Information/Texture_Pages.htm">텍스처 페이지</a> 에 함께 넣습니다. 레벨별 이미지가 있거나 플레이어와 적 등이 있는 경우에도 마찬가지입니다. 기본적으로 사용별로 그룹화하여 스왑을 최대한 줄이는 것이 좋습니다. 또한 <a class="glossterm" data-glossterm="VRAM" href="#">VRAM</a> 을 최적화된 상태로 유지하기 위해 다양한 <a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">프리페치 및 플러시</a> 기능을 사용하여 필요에 따라 메모리에서 텍스처를 로드하고 제거할 수 있습니다.</p><p class="note"> <span class="note">참고</span> 이 페이지의 시작 부분에서 언급했듯이 게임이 적절한 FPS로 잘 실행된다면 텍스처 스왑에 대해 너무 걱정하지 마십시오. 특히 데스크탑 타겟에서 프로젝트를 생성할 때 그렇습니다. 이러한 최적화는 대규모 게임이나 저가형 모바일 장치에서 사용할 때 가장 좋으며 잘못 사용하면 실제로 성능에 부정적인 영향을 미칠 수 있습니다.</p><p class="dropspot"> 정점 정보는 그리기를 위해 GPU에 &quot;배치&quot;로 전송되며 일반적으로 배치가 클수록 좋습니다. 따라서 그릴 때 배치를 &quot;중단&quot;하면 GPU로 전송되는 정점 배치 수가 증가하므로 피해야 합니다. 배치를 깨는 여러 가지가 있으며 주요 기능은 <strong>블렌드 모드</strong>, <strong>셰이더</strong> 변경, 무언가를 그리기 전에 셰이더의 유니폼 변경, 내장된 모양과 프리미티브를 사용하여 그리는 것입니다.</p><p class="dropspot"> 따라서 <span class="inline">bm_add</span> 혼합 모드 - 예를 들어 - 각각에 대해 새로운 정점 배치를 생성할 것입니다. 이는 확실히 나쁜 일입니다! 대신 게임에 다음과 같이 모든 총알을 그리는 컨트롤러 개체를 사용하세요.</p><p class="code">gpu_set_blendmode(bm_add);<br />
      <br />
      with (obj_BULLET)<br />
      {<br />
          draw_self();<br />
      }<br />
      <br />
      gpu_set_blendmode(bm_normal);
    </p><p class="note"> <span class="note">참고</span> 이것은 <span class="inline">gpu_set_blendenable()style="font-size: 14px">bm_add</span> 사용에만 적용되는 것이 아닙니다. 혼합 변경으로 인해 배치가 중단되고 성능이 저하됩니다.</p><p class="dropspot"> 이런 식으로 모든 총알이 같은 배치로 그려집니다. 기능의 현명한 사용 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline">gpu_set_alphatestref()</span></a>, <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline">gpu_set_alphatestenable()</span></a>, 그리고 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline">sprite_get_uvs()</span></a> 모든 유형의 그래픽 또는 프로젝트에 적합하지 않을 수 있지만 성능을 크게 향상시킬 수 있으며 프로젝트 코드 전체에서 필요에 따라 활성화/비활성화할 수 있습니다.</p><p class="note"> <span class="note">참고</span> 이러한 방식으로 컨트롤러를 사용할 때 인스턴스가 자체적으로 그릴 필요가 없는 경우 기본 그리기를 억제하기 위해 그리기 이벤트에 주석을 추가하거나 인스턴스를 보이지 않게 만들 수 있습니다(이렇게 하면 모든 코드가 실행되는 것을 방지할 수 있음). 모든 그리기 이벤트의 인스턴스).</p><p class="dropspot"> 이 숫자를 줄이는 또 다른 방법은 꼭 필요한 경우가 아니면 스프라이트에 대한 <strong>텍스처 페이지 분리</strong> 옵션을 비활성화하는 것입니다. 이러한 방식으로 저장된 각 이미지는 자체 텍스처 페이지로 전송되고 다르게 배치되므로 이러한 이미지를 일반 텍스처 페이지에 두는 것이 좋습니다. 그런 다음 다음을 사용하여 UVS 좌표를 얻을 수 있습니다. <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">surface_depth_disable()</span></a> 나중에 사용할 수 있도록 변수에 저장합니다. 소량의 추가 코드일 수 있지만 얻을 수 있는 부스트는 그만한 가치가 있습니다. 이 방법은 텍스처 반복을 허용하지 않습니다!</p><p class="dropspot"> 이 모든 팁과 마찬가지로 인생을 바꾸는 것이 더 어려워지고 게임이 잘 실행된다면 너무 걱정하지 마십시오...</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#">입자</a></p><div class="droptext" data-targetname="drop-down6"><p class="dropspot"> <a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">파티클</a> 은 게임에서 동적 효과를 생성하는 매우 빠르고 효율적인 방법을 제공하며 일반적으로 좋은 성능을 제공합니다. 그러나 파티클에 추가 블렌딩, 알파 블렌딩 및 색상 블렌딩을 사용하면 특히 모바일 대상에서 성능이 저하될 수 있으므로 필요하지 않은 경우 사용하지 마십시오! 특히 첨가제 혼합은 정점 배치를 크게 증가시킬 수 있으므로 주의해서 사용해야 합니다.</p><p class="dropspot"> WebGL이 아닌 HTML5 대상에서 여러 색상의 페이딩 입자를 사용하려면 많은 이미지 캐싱이 필요하고 매우 느립니다. 그러나 입자 스프라이트는 애니메이션할 수 있으므로 색상을 변경하는 하위 이미지가 있는 애니메이션 스프라이트를 만든 다음 대신 입자에 사용할 수 있습니다. 여전히 점진적인 색상 변경처럼 보이지만 캐시 이미지를 지속적으로 생성할 필요는 없습니다.</p><p class="dropspot"> 입자에 대한 자세한 내용은 입자 <a href="Guide_To_Using_Particles.htm">사용 안내서</a> 페이지에서 확인할 수 있습니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#">표면</a></p><div class="droptext" data-targetname="drop-down7"><p class="dropspot"> 마지막으로 <span data-keyref="GameMaker Name">GameMaker</span> 는 게임에서 사용할 때 <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">표면</a> 을 사용할 때 <strong>깊이 버퍼</strong> 를 켜고 끄는 기능과 같이 상당히 중요한 최적화 기능을 가지고 있기 때문에 표면 사용에 대해 간단히 설명하겠습니다.</p><p class="dropspot"> 표면을 평소처럼 사용하는 경우 <span data-keyref="GameMaker Name">GameMaker</span> 는 실제로 표면과 수반되는 깊이 버퍼를 생성하여 3D로 무엇이든 그릴 때 적절한 깊이 정렬을 보장합니다. 그러나 대부분의 2D 게임에서는 이 추가 깊이 버퍼가 필요하지 않으므로 다른 작업에 사용할 수 있는 추가 메모리 공간과 처리 시간을 차지합니다. 기능이 있는 곳입니다. <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline"></span></a> 활약하다...</p><p class="dropspot"> 이 함수는 깊이 버퍼 생성을 비활성화하기 위해 표면을 생성하기 전에 호출할 수 있으며, 이후에 생성된 모든 표면에는 깊이 버퍼가 생성되지 않습니다. 필요에 따라 이 기능을 활성화/비활성화할 수 있으며, 게임 시작 시 한 번만 호출하여 모든 후속 표면 호출에 대해 깊이 버퍼를 비활성화할 수도 있습니다(대부분의 2D 게임에서는 괜찮습니다). 성능이 크게 향상되지는 않지만 게임이 표면에 크게 의존하고 사양이 낮은 장치에서 게임의 메모리 부족을 막을 수 있는 경우 확실히 염두에 두어야 할 사항입니다.</p></div><p></p><p> 위에서 언급한 주요 사항 외에도 성능에 도움이 될 수 있고 &quot;우수 사례&quot;로 간주되는 다른 일반적인 사항이 있습니다.</p><ul class="colour"><li> 삼각 함수를 사용하는 것을 두려워하지 마십시오. (일반적인 믿음과 달리) 특히 입자, 충돌, 문자열 등과 비교할 때 매우 빠릅니다.</li><li> 그리기 이벤트에 물건을 그리기 위한 코드가 아닌 코드를 넣지 마십시오.</li><li> 알람을 사용하여 모든 단계에서 호출할 필요가 없는 코드를 호출합니다(어쨌든 이것을 Step 이벤트에 추가하는 대신).</li></ul><p> 그러나 페이지 시작 부분에서 언급했듯이 이러한 모든 최적화는 선택 사항이며 게임이 60개의 정점 배치, 80개의 텍스처 스왑, 추가 혼합 등으로 제대로 실행된다면 너무 걱정하지 마십시오! 다음 게임을 프로그래밍할 때 다음 사항을 염두에 두십시오... </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> 뒤로: <a href="Additional_Information.htm">추가 정보</a></div><div style="float:right"> 다음: <a href="The_File_System.htm">파일 시스템</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Nest Practices
-->
  <!-- TAGS
best_practices
-->
</body>
</html>