<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>프로그래밍 시 모범 사례</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="GameMaker Studio 2를 사용하여 프로그래밍할 때 몇 가지 모범 사례를 설명하는 페이지" />
  <meta name="rh-index-keywords" content="프로그래밍 시 모범 사례" />
  <meta name="search-keywords" content="모범 사례" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> 프로그래밍 시 모범 사례</h1><p> 이 페이지에서 우리는 게임을 프로그래밍할 때 몇 가지 &quot;모범 사례&quot;를 다룰 것이며 동시에 내부 작동에 대해 약간 설명할 것입니다.<span class="notranslate"></span>. 그러나 계속하기 전에 다음 두 가지 매우 중요한 점에 주목할 필요가 있습니다.</p><ul class="colour"><li> 이것은 <em>가이드</em> 이며 게임을 작성하는 100% 완벽한 방법이 아닙니다! 여기에 언급된 내용은 일반적으로 조직 및 미세 최적화 규모에 더 가깝고 편안하다고 느낄 때 프로그래밍 습관에 통합해야 합니다.<span class="notranslate"></span> 그리고 그것들이 적절하다고 생각합니다.</li><li> 게임이 잘 실행되고 있는 그대로 만족 <em>한다면 몇 가지 추가 FPS를 짜기 위해 모든 것을 변경하려고 서두르지 마십시오</em>. 읽기 쉽고 유연하며 모듈식 코드를 변경하는 데 필요한 시간과 에너지, 그리고 최종적으로는 전체적인 이득 사이에서 균형을 유지해야 합니다. 기본적으로 고장나지 않았다면 고치지 말고 다음 프로젝트를 위해 여기에서 배운 내용을 유지하세요.</li></ul><p> 이제 좋은 글을 쓰기 위한 몇 가지 일반적인 팁을 살펴보겠습니다.<span class="notranslate"></span> 언제든지 적용할 수 있는 코드...</p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">프로그래밍 스타일</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot"> 코드 작성과 관련하여 모든 사람은 <em>스타일</em> 이 있습니다. 프로그래밍 스타일은 대괄호를 배치하는 방법, 줄을 들여쓰는 방법, 변수를 선언하고 이름을 지정하는 방법 등이며 다른 사람(및 미래의 자신, 다른 일을 한 후 이 프로젝트로 돌아와야 할 때).</p><p class="dropspot"> 많은 <a href="http://en.wikipedia.org/wiki/Programming_style">프로그래밍 스타일</a> 이 있으며 일부는 자신의 스타일이 사용하기에 가장 좋은 스타일이라고 주장하지만 진실은 사용할 때 <strong>일관성</strong> 이 있고 모든 것이 무엇인지 <em>명확</em> 하고 <em>분명</em> 하다면 거의 모든 스타일이 괜찮다는 것입니다. 하다.</p><p class="dropspot"><img /> 위 이미지는 a에서 함수 선언의 예입니다.<span class="notranslate"></span> 위의 점을 설명합니다. JSDoc 스타일 주석을 사용하여 모든 기능을 명확하게 설명하고 코딩 스타일이 일관적이며 4개의 공백 들여쓰기, 로컬 변수에 사용되는 밑줄, 기록된 출력 등을 볼 수 있습니다.</p><p class="dropspot"> 또한 동안<span class="notranslate"></span> 편집기를 사용하면 각 여는/닫는 대괄호에서 코드를 접을 수 있습니다.<span class="inline index0"></span> 그리고<span class="inline index1"></span> 태그를 사용하여 코드의 일부를 분리하고 가독성을 크게 향상시킵니다. 특히 더 큰<span class="notranslate"></span> 여러 기능을 포함합니다. 지역도 주석을 달 수 있습니다 - 매뉴얼에서 이 페이지의 편집 섹션을 참조하십시오):</p><p class="dropspot"><img /> 코드를 작성할 때 최종 게임을 컴파일할 때<span class="notranslate"></span> 주석을 제거하고, 불필요한 줄 바꿈과 공백을 제거하고, 상수/매크로/열거형 값을 대체하고, 일반적으로 프로세스의 일부로 코드를 압축합니다. 즉, 코드 주위에 필요한 만큼 공백을 추가할 수 있으며 주석을 짧게 유지하거나 드물게만 사용하는 것에 대해 걱정할 필요가 없습니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">지역 변수 사용</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot"> 프로그래밍 스타일에 대한 위의 요점에서 계속해서 많은 초보자가 하는 한 가지는 코드 한 줄에 최대한 많은 것을 집어넣는 것입니다. 예를 들어:</p><p class="code"></p><p class="dropspot"> 완전히 읽을 수 없는 것은 아니지만 비효율적입니다(<span class="inline index2"></span> 예를 들어 함수가 두 번 호출됨) 보기가 지저분하고 어색합니다. 다음과 같이 표현하는 것이 훨씬 더 나을 것입니다.</p><p class="code"></p><p class="dropspot"> 이러한 지역 변수를 생성하는 데 필요한 메모리와 리소스는 무시할 수 있으며 명확성에서 얻는 즉각적인 이점(또는 나중에 코드를 읽는 다른 사람)보다 훨씬 중요합니다. 함수에도 동일한 아이디어를 적용해야 합니다. 입력 변수에 적절한 이름을 할당하고 가능한 한 읽기 쉽게 만들기 위해 필요한 경우 명확한 형식과 지역 변수를 사용해야 합니다.</p><p class="dropspot"> 지역 변수는 게임 내에서 빠르게 처리되므로 최대한 활용하고 표현식이 코드 블록이나<span class="notranslate"></span> 두 번 이상 로컬 변수를 만드는 것에 대해 생각하십시오. <a class="glossterm" data-glossterm="YoYo 컴파일러(YYC)" href="#">YoYo 컴파일러(YYC)</a> 대상을 사용할 때 참조하는 경우<span class="inline index3"></span> 또는 함수 또는 코드 블록에서 여러 번 인스턴스 변수를 사용하는 경우 코드 시작 부분에서 로컬 변수에 할당한 다음 해당 로컬 변수를 참조하는 것이 특히 유용합니다. 이렇게 하면 훨씬 더 나은 성능을 얻을 수 있기 때문입니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">배열</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"> <a href="../GameMaker_Language/GML_Overview/Arrays.htm">어레이</a> 는 사용이 빠르고 데이터 구조보다 메모리가 덜 필요하지만 더 최적화할 수 있습니다. 배열을 생성할 때 크기에 따라 메모리가 할당되므로 나중에 채울 계획이 없더라도 배열을 최대 크기로 먼저 초기화해야 합니다. 예를 들어, 최대 100개의 값을 보유하기 위해 배열이 필요하다는 것을 알고 있다면 다음을 사용하여 즉시 100개의 슬롯으로 초기화합니다. <a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline index4"></span></a> 함수:</p><p class="code"></p><p class="dropspot"> 이것은 모든 배열 값이 기본값 0으로 설정된 하나의 &quot;청크&quot;에 메모리를 할당하고 빠르게 유지하는 데 도움이 됩니다. 그렇지 않으면 배열에 새 값을 추가할 때마다 전체 메모리를 다시 할당해야 하기 때문입니다. 다시.</p><p class="note"> <span class="note">참고</span> HTML5 대상에서는 이와 같은 배열을 할당하는 것이 적용되지 않으며 이 대상에 대해 배열을 0에서 초기화해야 합니다! 예를 들어 os_browser 변수를 확인하여 이를 쉽게 처리할 수 있습니다.</p><p class="code"></p><p class="dropspot"> 사용된 변수를 0으로 설정하여 배열과 관련된 메모리를 확보할 수도 있습니다. 따라서 위의 코드 예제에서 배열을 지우려면 다음을 사용하기만 하면 됩니다.</p><p class="code"></p><p class="dropspot"> 또한 배열은 <strong>참조로 전달</strong> 되지만 변경이 있을 때 전체를 복사합니다(이 동작 <strong>을 쓰기 시 복사</strong> 라고 함). 따라서 배열을 함수에 전달하면 원래 배열에 <em>대한 참조</em> 를 전달하는 것이며 여기에서 읽은 모든 값은 원래 소스에서 가져옵니다. 이것은 훌륭하고 빠르지만 배열 값을 수정해야 하는 경우 쓰기 지점에서 배열 자체가 복제되고 변경된 사항 <strong>은 함수에서 반환되어야 하며 그렇지 않으면 손실됩니다</strong>. 이것은 훨씬 느리고 더 많은 메모리를 사용하므로 함수에서 배열을 사용하는 방법에 주의하십시오.</p><p class="dropspot"> 그러나 특수 배열 <a href="../GameMaker_Language/GML_Overview/Accessors.htm">접근자를</a> 사용하여 쓰기 시 복사 동작을 피할 수 있습니다.<span class="inline index5"></span>, 기본 배열에 직접 액세스할 수 있습니다. 예를 들어:</p><p class="code"></p><p class="code"></p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">데이터 구조</a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot"> 입력<span class="notranslate"></span> <a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">데이터 구조</a> 가 이전보다 훨씬 빠르게 최적화되었습니다.<span class="notranslate"></span> 버전. 메모리를 해제하는 데 사용하지 않을 때는 여전히 정리(파기)해야 하며, 예를 들어 배열보다 여전히 느릴 수 있지만 사용 용이성과 포함된 데이터를 처리하기 위한 추가 기능이 종종 더 중요할 수 있습니다. 최소한의 속도 차이이므로 게임에서 사용하는 것을 두려워하지 마십시오.</p><p class="dropspot"> 모든 데이터 구조 중에서 특히 DS Maps는 읽기 및 쓰기 속도가 빨라 모든 유형의 작업에 탁월한 옵션입니다.</p><p class="dropspot"> 이전에 배열에 대한 <a href="../GameMaker_Language/GML_Overview/Accessors.htm">접근</a> 자에 대해 언급했지만 데이터 구조에도 사용할 수 있으므로 코드를 정리하고 훨씬 더 읽기 쉽게 만들 수 있습니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">충돌</a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot"> <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">충돌을 처리하는 방법에는 여러 가지</a> 가 있습니다.<span class="notranslate"></span>, 그리고 그들 대부분은 약간의 추가 CPU 오버헤드가 첨부되어 있습니다. 그만큼<span class="inline index6"></span> 그리고<span class="inline index7"></span> 기능,<span class="inline index8"></span> 기능 및<span class="inline index9"></span> 함수는 모두 내에서 주어진 유형의 모든 인스턴스에 대한 <a class="glossterm" data-glossterm="경계 상자" href="#">경계 상자</a> 검사에 의존합니다.<span class="notranslate"></span>, 그리고 이러한 검사를 제한하기 위해 엔진에 몇 가지 최적화가 내장되어 있지만 충돌은 결코 처리하기에 가장 효율적인 것이 아닙니다. 정확한 충돌을 사용하기 시작하면 경계 상자 검사를 수행할 뿐만 아니라 실제로 매우 느린 픽셀 단위 검사도 수행하므로 성능도 눈에 띄게 악화됩니다. 이있다<span class="notranslate"></span> 여기에 대해 논의하는 기술 블로그:</p><ul class="dropspotlist"><li class="dropspot"> <a href="https://www.yoyogames.com/blog/32/the-hazards-of-precise-collision-detection">정확한 충돌 감지의 위험</a></li></ul><p class="dropspot"> 그렇다고 해서 이러한 기능을 사용하면 안 된다는 것은 아닙니다. 매우 편리할 수 있기 때문입니다. 그러나 모두 약간 다르게 작동하고 속도가 다르기 때문에 어느 것을 언제 사용해야 하는지 알아야 합니다. 대략적인 경험 법칙은<span class="inline index10"></span> 기능은 보다 빠릅니다.<span class="inline index11"></span> 보다 빠른 기능을 제공합니다.<span class="inline index12"></span> 그리고<span class="inline index13"></span> 기능이 있으므로 각 기능 유형에 대한 설명서의 페이지를 읽고 모든 상황에 가장 적합한 기능을 선택해야 합니다.</p><p class="dropspot"> 또는 타일 <a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">맵 기능</a> 이나 맞춤형 2D 어레이 또는 DS 그리드를 사용하여 생성할 수 있는 <strong>타일 기반 충돌 시스템</strong> 생성을 살펴보십시오. 이것은 매우 빠르며 게임 속도를 높이는 데 도움이 됩니다. 그러나 불규칙한 지형이나 벽을 사용하는 경우<span class="notranslate"></span> 그리드에 정렬되지 않으면 적절하지 않을 수 있습니다. 다음 비디오 링크에서 타일맵 충돌에 대한 매우 간단한 자습서를 찾을 수 있습니다.</p><ul class="dropspotlist"><li class="dropspot"> <a href="https://youtu.be/UyKdQQ3UR_0">GameMaker Studio 2의 타일 충돌</a></li></ul><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#">텍스처 스왑 및 정점 배치</a></p><div class="droptext" data-targetname="drop-down5"><p class="dropspot"> 만약 너라면<span class="notranslate"></span> <a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>디버그 오버레이</strong></a> 에서 테스트할 때 화면 상단의 대괄호 안에 두 개의 그림이 있는 것을 볼 수 있습니다. 첫 번째는 수행 중인 <strong>텍스처 스왑</strong> 의 수이고 두 번째는 <strong>정점 배치</strong> 의 수입니다. 많은 요인이 이 수치에 영향을 미치며 엔진이 각 단계마다 하나 또는 두 개를 필요로 하므로 절대 (0)(0)으로 낮추지 않을 것이지만 이러한 값을 가능한 한 낮추는 것을 목표로 해야 합니다.</p><p class="dropspot"><img /> 을위한<span class="notranslate"></span> 스왑, 이를 수행하는 가장 효율적이고 효율적인 방법은<span class="notranslate"></span> 배경이 저장됩니다.<span class="notranslate"></span> 페이지. 이것은 <a href="../The_Asset_Editors/Sprites.htm">sprite 속성</a> 에서 수행되며 다음을 만들 수 있습니다.<span class="notranslate"></span> <a href="../Settings/Texture_Groups.htm">텍스처 그룹 편집기</a> 의 페이지. 예를 들어 주 메뉴에서만 사용되는 이미지가 여러 개 있는 경우 별도의 <a href="../Settings/Texture_Information/Texture_Pages.htm">텍스처 페이지</a> 에 함께 넣습니다. 레벨별 이미지가 있거나 플레이어와 적 등이 있는 경우에도 마찬가지입니다. 기본적으로 사용별로 그룹화하여 스왑을 최대한 줄이는 것이 좋습니다. 또한 <a class="glossterm" data-glossterm="VRAM" href="#">VRAM</a> 을 최적화된 상태로 유지하기 위해 다양한 <a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">프리페치 및 플러시</a> 기능을 사용하여 로드 및 제거할 수 있습니다.<span class="notranslate"></span> 필요에 따라 메모리에서.</p><p class="note"> <span class="note">참고</span> 이 페이지의 시작 부분에서 언급했듯이 게임이 적절한 FPS로 실행된다면 너무 걱정하지 마십시오.<span class="notranslate"></span> 스왑... 특히 데스크탑 대상에서 프로젝트를 생성할 때. 이러한 최적화는 대규모 게임이나 저가형 모바일 장치에서 사용할 때 가장 좋으며 잘못 사용하면 실제로 성능에 부정적인 영향을 미칠 수 있습니다.</p><p class="dropspot"> 정점 정보는 그리기를 위해 GPU에 &quot;배치&quot;로 전송되며 일반적으로 배치가 클수록 좋습니다. 따라서 배치를 &quot;중단&quot;하면 GPU로 전송되는 정점 배치 수가 증가하므로 그릴 때 피해야 합니다. 배치를 깨는 여러 가지가 있으며 주요 기능은 <strong>혼합 모드</strong>, <strong>셰이더</strong> 변경, 유니폼 변경입니다.<span class="notranslate"></span> 무언가를 그리기 전에 내장된 모양과 기본 요소를 사용하여 그리기.</p><p class="dropspot"> 따라서<span class="inline index14"></span> 블렌드 모드 - 예를 들어 - 각각에 대해 새로운 정점 배치를 생성할 것입니다. 이는 확실히 나쁜 일입니다! 대신 컨트롤러가 있습니다.<span class="notranslate"></span> 다음과 같이 대신 모든 총알을 그리는 게임에서:</p><p class="code"></p><p class="note"> <span class="note">참고</span> 이것은 <span class="inline" style="font-size: 14px">bm_add</span> 사용에만 적용되는 것이 아닙니다. 혼합 변경으로 인해 배치가 중단되고 성능이 저하됩니다.</p><p class="dropspot"> 이런 식으로 모든 총알이 같은 배치로 그려집니다. 기능의 현명한 사용 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline index15"></span></a>, <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline index16"></span></a>, 그리고 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline index17"></span></a> 모든 유형의 그래픽 또는 프로젝트에 적합하지 않을 수 있지만 성능을 크게 향상시킬 수 있으며 프로젝트 코드 전체에서 필요에 따라 활성화/비활성화할 수 있습니다.</p><p class="note"> <span class="note">참고</span> 이러한 방식으로 컨트롤러를 사용할 때 인스턴스가 자체적으로 그릴 필요가 없는 경우 기본 드로잉을 억제하기 위해 그리기 이벤트에 주석을 추가하거나 인스턴스를 보이지 않게 만들 수 있습니다(이렇게 하면 모든 코드가 실행되는 것을 방지할 수 있지만 모든 그리기 이벤트의 인스턴스).</p><p class="dropspot"> 이 숫자를 줄이는 또 다른 방법은 <strong>분리<span class="notranslate"></span> 페이지</strong> 옵션<span class="notranslate"></span> 절대적으로 필요한 경우가 아니면. 이 방법으로 저장된 각 이미지는 자체적으로 전송됩니다.<span class="notranslate"></span> 페이지 및 일괄 처리 방식이 다르기 때문에 이러한 이미지를 정기적으로<span class="notranslate"></span> 페이지가 더 좋습니다. 그런 다음 다음을 사용하여 UVS 좌표를 얻을 수 있습니다. <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline index18"></span></a> 나중에 사용할 수 있도록 변수에 저장합니다. 적은 양의 추가 코드일 수 있지만 얻을 수 있는 부스트는 그만한 가치가 있습니다. 이 방법은 허용되지 않습니다.<span class="notranslate"></span> 반복!</p><p class="dropspot"> 이 모든 팁과 마찬가지로 인생을 바꾸는 것이 더 어려워지고 게임이 잘 실행된다면 너무 걱정하지 마십시오...</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#">입자</a></p><div class="droptext" data-targetname="drop-down6"><p class="dropspot"> <a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">파티클</a> 은 게임에서 동적 효과를 생성하는 매우 빠르고 효율적인 방법을 제공하며 일반적으로 좋은 성능을 제공합니다. 그러나 파티클에 추가 블렌딩, 알파 블렌딩 및 색상 블렌딩을 사용하면 특히 모바일 타겟에서 성능이 저하될 수 있으므로 필요하지 않은 경우 사용하지 마십시오! 특히 첨가제 혼합은 정점 배치를 크게 증가시킬 수 있으므로 주의해서 사용해야 합니다.</p><p class="dropspot"> WebGL이 아닌 HTML5 대상에서 여러 색상의 페이딩 입자를 사용하려면 많은 이미지 캐싱이 필요하며 매우 느립니다. 그러나 입자 때문에<span class="notranslate"></span> 애니메이션을 만들 수 있습니다 애니메이션을 만들 수 있습니다<span class="notranslate"></span> 색상을 변경한 다음 대신 입자에 사용하는 하위 이미지가 있습니다. 여전히 점진적인 색상 변화처럼 보이지만 지속적으로 생성할 필요는 없습니다.<span class="notranslate"></span> 이미지.</p><p class="dropspot"> 입자 <a href="Guide_To_Using_Particles.htm">사용 안내서</a> 페이지에서 입자에 대해 자세히 알아볼 수 있습니다.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#">표면</a></p><div class="droptext" data-targetname="drop-down7"><p class="dropspot"> 마지막으로 다음과 같이 <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">표면</a> 사용에 대해 간략하게 설명합니다.<span class="notranslate"></span> 게임에서 사용할 때 상당히 중요한 최적화가 있습니다.<span class="notranslate"></span> <strong>깊이 버퍼</strong> 를 켜고 끕니다.</p><p class="dropspot"> 표면을 정상적으로 사용할 때 GMS2는 실제로 표면과 그에 수반되는 깊이를 생성합니다.<span class="notranslate"></span> 3D로 무엇이든 그릴 때 적절한 깊이 정렬을 보장합니다. 그러나 대부분의 2D 게임에서 이 추가 깊이는<span class="notranslate"></span> 필요하지 않으며 다른 작업에 사용할 수 있는 추가 메모리 공간과 처리 시간을 차지합니다. 기능이 있는 곳입니다. <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline index19"></span></a> 활약하다...</p><p class="dropspot"> 깊이를 비활성화하기 위해 표면을 생성하기 전에 이 함수를 호출할 수 있습니다.<span class="notranslate"></span> 생성 후 생성된 모든 표면에는 깊이가 없습니다.<span class="notranslate"></span> 그들을 위해 만들어졌습니다. 필요에 따라 이 기능을 활성화/비활성화할 수 있으며 게임 시작 시 한 번만 호출하여 깊이를 비활성화할 수도 있습니다.<span class="notranslate"></span> 모든 후속 표면 호출에 대해(대부분의 2D 게임에서는 괜찮습니다). 성능이 크게 향상되지는 않지만 게임이 표면에 크게 의존하고 사양이 낮은 장치에서 게임의 메모리 부족을 막을 수 있는 경우 염두에 두어야 할 사항입니다.</p></div><p></p><p> 위에서 언급한 주요 사항 외에도 성능에 도움이 될 수 있고 &quot;우수 사례&quot;로 간주되는 다른 일반적인 사항이 있습니다.</p><ul class="colour"><li> 삼각 함수를 사용하는 것을 두려워하지 마십시오. (일반적인 믿음과는 반대로) 특히 입자, 충돌,<span class="notranslate"></span>, 등...</li><li> Draw 이벤트에 물건을 그리기 위한 코드가 아닌 코드를 넣지 마세요.</li><li> 알람을 사용하여 모든 단계에서 호출할 필요가 없는 코드를 호출합니다(어쨌든 이것을 Step 이벤트에 추가하는 대신).</li></ul><p> 그러나 페이지 시작 부분에서 언급했듯이 이러한 모든 최적화는 선택 사항이며 게임이 60개의 정점 배치, 80개의<span class="notranslate"></span> 스왑, 첨가제 블렌딩 등, 너무 걱정하지 마십시오! 다음 게임을 프로그래밍할 때 다음 사항을 염두에 두십시오. </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> 뒤로: <a href="Additional_Information.htm">추가 정보</a></div><div style="float:right"> 다음: <a href="The_File_System.htm">파일 시스템</a></div></div></div><h5> <span data-keyref="Copyright Notice">© 저작권<span class="notranslate"></span> 2022년 판권 소유</span></h5>
  </div>
  <!-- KEYWORDS
Nest Practices
-->
  <!-- TAGS
best_practices
-->
</body>
